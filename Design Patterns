                           Design Patterns
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                        â–¼                        â–¼

Creational Patterns     Structural Patterns       Behavioral Patterns
-------------------     ---------------------      ----------------------
- Singleton             - Adapter                 - Observer
- Factory Method        - Bridge                  - Strategy
- Abstract Factory      - Composite               - Command
- Builder               - Decorator               - Chain of Responsibility
- Prototype             - Facade                  - Mediator
                        - Flyweight               - State
                        - Proxy                   - Template Method
                                                  - Iterator
                                                  - Visitor
                                                  - Interpreter
                                                  - Memento



==============================================================

                                      Design Patterns
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â–¼                            â–¼                            â–¼

    Creational Patterns            Structural Patterns           Behavioral Patterns
    -------------------           ---------------------          ----------------------
    â”œâ”€â”€ Singleton                 â”œâ”€â”€ Adapter                   â”œâ”€â”€ Observer
    â”‚   â†’ Ensures one instance    â”‚   â†’ Converts incompatible    â”‚   â†’ Notifies dependent objects 
    â”‚     exists globally.        â”‚     interfaces into one.     â”‚     when subject changes.
    â”‚                             â”‚                             â”‚   â†’ Useful in event-driven systems.
    â”œâ”€â”€ Factory Method            â”œâ”€â”€ Bridge                    â”œâ”€â”€ Strategy
    â”‚   â†’ Creates objects via     â”‚   â†’ Separates abstraction    â”‚   â†’ Defines a family of algorithms, 
    â”‚     interface, not class.   â”‚     from implementation.     â”‚     allowing interchangeability.
    â”œâ”€â”€ Abstract Factory          â”œâ”€â”€ Composite                 â”œâ”€â”€ Command
    â”‚   â†’ Creates related object  â”‚   â†’ Treats groups and        â”‚   â†’ Wraps requests into objects
    â”‚     families without class. â”‚     individual objects same. â”‚     for queuing or logging.
    â”œâ”€â”€ Builder                   â”œâ”€â”€ Decorator                 â”œâ”€â”€ Chain of Responsibility
    â”‚   â†’ Builds complex objects  â”‚   â†’ Adds new functionality   â”‚   â†’ Passes request along a chain
    â”‚     step by step.           â”‚     to objects dynamically.  â”‚     until it is handled.
    â””â”€â”€ Prototype                 â”œâ”€â”€ Facade                    â”œâ”€â”€ Mediator
        â†’ Clones existing object  â”‚   â†’ Provides unified access  â”‚   â†’ Centralizes interactions
          to avoid re-creation.   â”‚     to subsystem methods.    â”‚     between multiple objects.
                                  â”œâ”€â”€ Flyweight                 â”œâ”€â”€ State
                                  â”‚   â†’ Minimizes memory by      â”‚   â†’ Allows object to change
                                  â”‚     sharing common data.     â”‚     behavior when its state changes.
                                  â””â”€â”€ Proxy                     â”œâ”€â”€ Template Method
                                      â†’ Controls access to a      â”‚   â†’ Defines steps of an algorithm,
                                        real object or resource.  â”‚     letting subclasses override parts.
                                                                  â”œâ”€â”€ Iterator
                                                                  â”‚   â†’ Provides access to collection 
                                                                  â”‚     elements sequentially.
                                                                  â”œâ”€â”€ Visitor
                                                                  â”‚   â†’ Lets you define new operations 
                                                                  â”‚     without changing the classes.
                                                                  â”œâ”€â”€ Interpreter
                                                                  â”‚   â†’ Parses and evaluates language 
                                                                  â”‚     grammar or expressions.
                                                                  â””â”€â”€ Memento
                                                                   â†’ Captures object state to restore 
                                                                     it later without violating encapsulation.



========================================================

Singleton
â†’ Ensures a class has only one instance throughout the application.
â†’ Provides a global point of access to that instance.

Key Features:

Private constructor to restrict object creation.

A static field to hold the single instance.

A public static method to return the instance.


Great question! In Java, there are **multiple ways to create a Singleton**, each with different pros and cons, especially regarding **thread-safety, lazy initialization**, and **simplicity**.

---

### âœ… **1. Eager Initialization**

```java
public class Singleton {
    private static final Singleton instance = new Singleton();
    private Singleton() { }
    public static Singleton getInstance() {
        return instance;
    }
}
```

* **When:** Instance is created at class loading.
* **Pros:** Thread-safe, simple.
* **Cons:** Instance is created even if not used.

---

### âœ… **2. Lazy Initialization**

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() { }
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

* **When:** Instance is created only when needed.
* **Cons:** **Not thread-safe** in multithreaded environments.

---

### âœ… **3. Thread-Safe Singleton (Synchronized Method)**

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() { }
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

* **Pros:** Thread-safe.
* **Cons:** Synchronized method has performance cost.

---

### âœ… **4. Double-Checked Locking (Recommended)**

```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() { }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

* **Pros:** Thread-safe and efficient.
* **Cons:** Slightly complex code.

---

### âœ… **5. Bill Pugh Singleton (Static Inner Class)**

```java
public class Singleton {
    private Singleton() { }
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

* **Pros:** Lazy-loaded, thread-safe without synchronization.
* **Highly recommended.**

---

### âœ… **6. Enum Singleton (Best & Simplest)**

```java
public enum Singleton {
    INSTANCE;
    public void doSomething() {
        // behavior
    }
}
```

* **Pros:** Thread-safe, handles serialization, protects against reflection.
* **Best practice as per Effective Java by Joshua Bloch.**

---

### ğŸ” Summary Table:

| Method                    | Lazy? | Thread-Safe | Simple | Recommended |
| ------------------------- | ----- | ----------- | ------ | ----------- |
| Eager Initialization      | âŒ     | âœ…           | âœ…      | Sometimes   |
| Lazy Initialization       | âœ…     | âŒ           | âœ…      | âŒ           |
| Synchronized Method       | âœ…     | âœ…           | âœ…      | âš ï¸          |
| Double-Checked Locking    | âœ…     | âœ…           | âš ï¸     | âœ…           |
| Static Inner Class (Pugh) | âœ…     | âœ…           | âœ…      | âœ…âœ…          |
| Enum Singleton            | âœ…     | âœ…           | âœ…âœ…     | âœ…âœ…âœ…         |



