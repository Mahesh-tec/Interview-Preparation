Java Interview Questions Boot camp  1000 questions:

https://github.com/basicsstrong/java_interview_questions.git


Operators:

How many types of operators are present in java?
		There are :
		1. Arithmetic Operators
		2. Unary Operators
		3. Assignment Operator
		4. Relational Operators
		5. Logical Operators
		6. Bitwise Operators
		7. Shift Operators
		8. Ternary Operator

What are Arithmetic operators?
		Arithmetic operators are used to perform simple arithmetic operations on primitive data types.
		These are;
				+ Addition Operator
				- Subtraction Operator
				* Multiplication Operator
				/ Division
				% Modulo operator

Can we add two short values to a short type?
		No we cannot. Addition of two short type numbers will be int. If we Try to assign it too short we
		will get an error.

		üëâüèª Any operation between two integer type variables which are smaller than int, will always results in
		an int.

What are Unary Binary and Ternary operators?
		Unary Operators are the operators which operate on only one operand.
		Binary Operators operate on two operands and Ternary operators operate on Three operands.

		üëâüèª We have Arithmetic, Assignment, Relational, Logical, Bitwise, Shift Operators which takes
		two operands to operate on.

Explain Unary operators.
		Unary operators are such operators which needs only one operand and are used to increment decrement
		value or inverting the value.

		1. Unary plus + : used for giving positive values.
		2. Unary minus - : used for negating the values

		3. Increment operator ++ : increments the value by 1.
							There two ways in which we can use this operator,
									-> Post-increment and Pre-increment
															a++;	++a;
															Post	pre

	-> What is the difference between ++a and a++ under increment operators?
				In post increment the value gets incremented by 1 after computing the result.

		4. Decrement operator -- : decrements value by 1.
							Two ways to use this, post decrement and pre decrement.

		5. Logical not operator ! : which is used for inverting a boolean value.

What is Assignment Operator, and what are Compound Assignment operators?
		Assignment operator: '='
				This operator is used to assign a value to any variable.
				It assigns value given on the right hand side of the operator to the left hand side variable.

				variable = value;

		Compound Assignement :
				Combining Assignment operator with other operators.
				These are compound statements:
					+=, -=, *=, /=, %=

Which operators are used to compare the primitives with each other?
		Relational Operators.
		These operators are used compare two operands. like, if an element is equals to another or not. Such operators return boolean result.

		These are some relational operators:

		1. == (equal to): returns true if left hand side value is equal to right one.

					a= 10, b= 20
					System.out.println((a==b));		prints false

		2. != (Not equal to): returns true if left side value is not equal to right one.

					System.out.println((a!=b));		prints true

		3. < (less than): returns true if left side value is less than the right one.

					System.out.println((a<b));		prints true

		4.  > (greater than)

		5. <= (less than or equals to) : this will return true if the value at left side is either less than
				or equal to the value at right side.

		6. >= (greater than or equal to)

What is the difference between the statement a = a+b and a+=b?
		This compound assignment [+=] implicitly cast the result of addition into the type of variable used
		to hold the result.

Can we cast an int value into byte variable?
		Yes we can cast.
				int a = 10;
				byte b = (byte) a;

What will happen if the value of int is larger than the byte?
		An int is 32 bit long, while byte is 8 bit long. When we cast an int to byte, the higher 24 bits
		will be lost as byte can only hold value from -128 to 128.

What is difference between equal to (==) and .equals() ?
		The equality operator is a binary operator which is provided by java to compare primitives and objects.
		Whereas .equals() is a method defined by Object class, which is used to compare objects.

		In order to compare objects:
		Equality operator (==) returns true only if both objects references points to the same object.
		while equals() returns true if both have same value.

What will this return : 3*0.1 == 0.3? True or False?
		Logically this should return true, But This will return false.
		Because some floating point numbers can not be represented exactly.

What are logical operators?
		Logical operators are used to perform the logical AND and logical OR operations.
				Operands with logical statements are conditions, which results into true or false.

		1. && (Logical AND): returns true when both conditions are true.

		2. || (Logical OR) : This returns true either the condition present in left side returns true or
												 condition at right returns true.

		üëâüèª Relational operators and Logical operators are used mostly in looping statements and conditional
			 statements.

What are Bitwise Logical Operators in java?
		Bitwise operators are used to perform operations on individual bits of number for example,
		These are the bitwise operators:

		1. Bitwise AND Operator & : which returns bit by bit AND of input values.
		2. Bitwise OR Operator | : which returns bit by bit OR of input values.
		3. Bitwise XOR Operator ^ : which returns bit by bit XOR of input values.
		4. Bitwise Complement Operator ~ : the unary operator which returns one-s complement representation
		 																	 of input value.

		We can use these operators with any of the integer type.

		We can also use Bitwise OR and Bitwise AND operators in conditional statements.

What is difference between Logical OR and Bitwise OR?
		While operating, The logical OR operator does not check second condition if first condition is true.
		It checks second condition only if first condition is false.
		Whereas the bitwise OR operator always checks both conditions, whether first condition is true or not.

What is Ternary Operator (Conditional) in java?
		In java, Ternary operator is a shorter version of if-else statement.
		It has three operands:

		Condition ? If true : if false

Explain Shift operators in java.
		There are two types of Shift operators:
		Left Shift <<
		Right Shift >>

		The Left shift operator in java is used to shift all the bits in a value to the left side of a
		specified number of times.

		And Right shift operator is used to move left operands value to the right by the number of bits
		specified by the right operand.

What is the difference between >>(Bitwise right shift operator) and >>>(bitwise zero fill right shift)?
		This '>>>' is also used to shift the bits towards right. But it is different from the regular '>>',
		as it does not protect the sign bit of the number, while '>>' protects the sign bit.
		üëâüèª '>>>' this always fills 0 in the sign bit.

What is the precedence of operators available in java?
		When it comes to hybrid equations, which have more than one or two operators,
		then the operators which have higher precedence are solved first.

What is instanceof operator?
		This operator is used to check if an object is an instance of a Class or a subclass.

				object instanceof class/subclass/interface

		-> This operator is used for Type Checking.



What is Java Collection Framework?
    A java collection framework is a collection of interfaces and classes which are used to store and
    process data efficiently, as a Collection is something which is used to store Data objects.

    This framework was introduced in Java version 1.2.
    -> Reduced the development effort.
    -> Code quality is enhanced.

What are the basic interfaces of collection framework?

    1. Collection
    2. List
    3. Set
    4. Queue
    5. Map

Why Map Interface does not extend Collection interface?
    The Map is way different than collection. In Map there are no elements, it has key-value pairs.
    üëâüèª It does not fit into the Group of elements Paradigm.

    However there are many methods to retrieve keys and values as collection.

What is the difference between Collection and Collections?

Why Collection Interface does not extend Serializable and Cloneable interfaces?
    'There is no need to do it!'
    Collection is not supposed to do what Cloneable and Serializable interfaces do.

    What they do?
    They are just the marker interfaces which are actually empty interfaces.

    üëâüèª If Collection Interface implements these interfaces then it will mandate cloning and serialization
    in all implementation, which is less flexible and more restrictive.

When we had Array, Why do we need collection?
    We know Array is a group of primitives.. which holds homogeneous data.
    It has also some limitations like, arrays are always fixed in size.
    So to overcome these problems, collection were introduced.
    Collection, which can also be called a container, is a group of individual objects.

    How can it solve the problems that we had in array?

    Collections are grow-able in Nature,
    that means we aren't bound to declare size of any collection at declaration as we are with arrays.
    Size of collections can be increased or decreased on the base of our programming requirement.
    You can add or remove any number of elements in collection.

    hence collections solve the first limitation.

    And next,
    we only can have homogeneous type of data elements in array,
    But Collections can have any kind of data element. They can be homogeneous or heterogeneous.

when we should use arrays and when collection?
    Array are recommended to use if we know the size in advance..
    because Performance-wise Arrays are better to use than Collections.

    From Memory point of view, we should not use 'Arrays'..
    Suppose we take an array of 100 size. And if we only have 10 elements in it, so,
    here the rest of the memory blocks get wasted. Thats why arrays are not recommended to use in memory point of view.
    On the other hand, Collections are grow-able or resizable in nature, and it uses memory as per required only.

What is the difference between Array and ArrayList?
    The very first difference between Array and ArrayList is,
    Array can contain primitive or Objects whereas ArrayList can only contain Objects.
    next is
    Arrays are fixed in size whereas ArrayList size is dynamic.
    And, ArrayList accepts duplicate objects unlike arrays..
    Array does not provide a lot of features like ArrayList, such as add(), addAll(), removeAll() etc..

    So ArrayList is the obvious choice when we work on list.. But if the size of list is fixed and if we are using the list of primitives then we should use Arrays.. Although collection use auto boxing to reduce the coding effort but still it makes them slow.. so would use array with primitives.
    And if are working on multidimensional situation, then also using array [][] is way more easy than List<List<>>..

How LinkedList is different from ArrayList?
    ArrayList and LinkedList both implement the List interface but there are some differences between them..

    ArrayList is an indexed based data structure.. The underlying data structure for ArrayList is a resizable or growable Array.

    And LinkedList is a data structure which stores data and its address as list of nodes.. here, every node is linked to its previous and next node using pointers.. That is, the address part of the element points to the next element of the linked list.so see the address that the first node is having.. is actually the address of the next node.

    This is how we create ArrayList, and linkedLists

    ArrayList<String> al = new ArrayList<String>();
    //and to add elements.. these are the methods.. (explain the suggestions)
    al.add("John");
    al.add("Rohn");

    LinkedList<String> lList = new LinkedList<String>();
    lList.add("");

    Since ArrayList is index based data structure, it provides random access to its elements with the performance of O(1).. that is, we can access any element by the index.. Linked list also allows to get any element by index, but internally it traverse the list from start to read at the index node, then return the element. So the performance is O(n) which is slower than of arrayList. Therefore the ArrayList is recommended to use retrieving data..

    Next thing is, Insertion and removal of any element is faster in LinkedList compared to ArrayList. Because one insertion or deletion in middle requires n number of shifts.. So there is no concept of resizing array when element is added in middle..

    and in linkedList it requires only one change in the address pointer of the particular node to add or remove any element.

    Next is,
    LinkedList consumes more memory than ArrayList because every node in LinkedList stores reference of previous and next elements..'

What are the different ways to iterate over a list?
    To access or to get elements from collection there are many ways present in java.
    1. Loops (classic for loop)
    2. Cursors
        In java these are the cursors available for collections:
            1. Iterator
            2. ListIterator
            3. Enumeration

What is the difference between Iterator and ListIterator and Enumeration?

What are the legacy implementations?
    Vector is a legacy class.
    Legacy class: The classes that were already there before introducing collection framework.

    Sub Class of Vector -> Stack, is also a legacy class.

    Vector is implemented on a growable or a resizable array.
        -> It is an ordered collection
        -> allows duplicates.

    Vector v = new Vector();

    Stack implements the stack data structure. It is based on the principle of Last In First Out.
        üëâüèª element which is inserted in last, will be the first one to come out.

    Stack s = new Stack();

      -> to insert any object : push()
      -> to remove the top element : pop()

What are the similarities and difference between ArrayList and Vector?

Which collection classes provide random access of its elements?
    These are the collection classes which provide random access:
        ArrayList, Vector, Stack, HashMap, TreeMap, Hash-table.

What are Stack and Queue? How they are different?
    Stack and Queue are used to store data before processing them.

    Queue represents an ordered list of objects which is limited to insert elements
    at the end of the list and removing from the start..

    This is how we create a queue,

    Queue<Integer> q = new LinkedList<>();

    being an interface it needs the concrete classes to create objects,
    PriorityQueue and LinkedList are most common to use.

    And to add element,
    q.add(10);
    q.add(20);

    sysout(q);

    and the remove method will remove the head that is the first element

    int a = q.remove();		//return the removed element
    sysout("element removed- "+a)

    sysout(q);

    So Queue allows retrieval of element in First In First Out order. and it is different from stack as Stack allows elements to be retrieved in Last In First out order.

    Stack<Integer> st = new Stack<>();
    st.push(10);
    st.push(20);

    To pop,
    st.pop();

    sysout(st);

    So thats the difference between Stack and queue.. Stack is a class and queue is an interface.

How can we sort Collections?
    There are some implementations of set and map which are used to store elements in a sorting order.
    -> SortedMap, SortedSet etc. - can be used to get a sorted collection(Map or Set).

    To sort List implementations, the Collections provides method sort().

    Collections.sort(): sorts list implementation passed to it.

    -> It does not return anything just sorts the collection.

How to make a collection read only?
    We can create a read only collection by using unmodifiableCollection method of Collections class.

    Collections.unmodifiableCollection(Collection c)

    -> if any operation occurs it will throw UnsupportedOperationException.

How can we make a collection thread-safe?
    There is a method in Collections class ->
    synchronizedCollection(Collection c) : used to get a synchronized or thread-safe collection.

What is the difference between Set and List?
    Both Set and List are used to store objects and provides convenient way to insert,
    remove and retrieve elements and also provides support for iteration.

    Fundamental differences between List and Set:
     1. Allowing Duplicate Elements
     2. Order

When should we use List and when to use Set??
    üëâüèª If we need to maintain insertion order and we can have duplicates too then we use List.
    üëâüèª If we want a collection of unique objects then we should use Set.

How does HashSet is implemented? How does it use Hashing?

What are Comparable and Comparator interface? When to use what?

Whats difference between TreeSet and LinkedHashSet and HashSet?
    These are the implementations of Set.

    Starting with TreeSet, the main feature of TreeSet is Sorting.
    Its the implementation class of sortedSet.
    So in TreeSet the insertion of elements is done on some sorting order.
    like we want to store all the Employee's object according to their EmployeeIds then we should
    go for SortedSet or TreeSet.
    Also in treeSet, we cannot put heterogeneous elements in it.
    Its about sorting as we cannot sort different type of objects so it is restricted to insert diff data types in treeSet.

    SortedSet<Integer> t = new TreeSet<>();

    It will creates an TreeSet object in which elements to be inserted in Default natural sorting order.
    Note that, If we are depending on the default natural sorting order, then our elemtns/object should be...
    homogeneous and comparable, otherwise we will get classCastException.

    So we can add integer only.
    t.add(10);
    t.add(5);
    sysout(t);

    This will add both elements in ascending order by default.

    And next is LinkedHashSet.. it was introduced in 1.4 version. It is the sub class of Hashset (no insertion order) where insertion order is preserved.
    And that's the main difference between HashSet and LinkedHashSet.

    We create linkedHashSet like,
    LinkedHashSet lhs = new LinkedHashSet();

    So all of the three, TreeSet, LinkedHashSet and HashSet doesn't allow to store duplicates.
    And none of these are thread-safe..
    But HashSet is the Fastest among them.
    LinkedHashSet comes second or can be similar to HashSet but
    TreeSet is slower because it performs sorting for each insertion.

    Next difference between these, is ordering.
    HashSet doesn't maintain any order while LinkedHashSet maintains insertion order
    and treeSet maintains sorting order of elements.

    And talking about internal implementations,
    HashSet is backed by HashMap..
    whereas LinkedHashSet is implemented using HashSet and LinkedList.
    And TreeSet, it is backed up by navigableMap and it internally uses TreeMap.

    Next difference is about way of comparing things,
    like HashSet and LinkedHashSet uses equals() for comparison
    and TreeSet uses compareTo() method for maintaining ordering.
    This was all about differences between them.

Can we add a null element to TreeSet and HashSet?
    We can add a null element in HashSet but not in treeSet.

    üëâüèª TreeSet uses compareTo() method to compare objects with each other, if any element will be null
    by any chance, it will throw NullPointerException.

What is difference between poll() and remove() methods of Queue?
    Both of these methods are used to remove element and returns the head of the queue. The difference is,

    -> if the queue is empty and we call the remove() method, then it will throw exception,
    but if we call poll() method, it will return null.

What is the difference between remove() method of Collection and remove() method of Iterator?
    Collection.remove() is used for removing object from collection, while not iterating.

    -> When we use this remove() method to remove element at the time of iteration then it may throw
    ConcurrentModificationException.

    -> Iterator.remove() is advised to use for remove element while iterating.

How HashMap works in Java?

Whats the difference between HashMap and HashTable?

Can we use a Custom object as a key in HashMap? If yes then How?
    Yes! we may create custom object key for HashMap.
    -> for that we need to override the equals() and hashcode() method to the Class which we want to use
    as key.

Why it is suggetsed to have immutable objects as keys in hashMap?
  //why string is popular hasmap key in java?
    -> if we want to use custom object as key, we need to ensure that the hashcode() of the key of hashMap
    does not change. If it happens then it is impossible to get object value from that key.

What is the contract of equals() and hashCode() method?
    üëâüèª If two objects are equal, then they must have the same hashcode.
    üëâüèª if two objects have the same hash code, then they may or may not be equal.

    //Equal objects must produce same hashcode
	   //a.equals(b) -> true    then  a.hashCode() = b.hashCode()

  	//unequal objects need not produce same hashcode
  	//a.equals(b) -> false    then  a.hashCode() = b.hashCode() -> true
  	//a.equals(b) -> false    then  a.hashCode() = b.hashCode() -> false

What is the NavigableMap?

What is the difference between HashMap and HashSet in java?
    üëâüèª HashMap is collection of key-value pairs whereas HashSet is an un-ordered collection of unique
    elements!

What are IdentityHashMap and WeakHashMap? How they are different?

When to use HashMap and when to use TreeMap?
    üëâüèª HashMap is the best implementation of Map for inserting, deleting, and locating elements.

    üëâüèª TreeMap is the better alternative if we need to traverse the keys in a sorted order.

    -> HashMap is faster than TreeMap; for sorted key traversal, it is faster way to add elements to a
    HashMap, and then convert the map to a TreeMap.


//Concurrent Collections
//java.util.concurrent v5

What is iterator's fail-fast property?
    While iterating over any collection, we cannot perform any modification on elements.
    Whenever we access the next element in collection, Iterator's fail fast property checks for any
    modification in the structure of that collection.'
    -> If any modifications found, it throws RuntimeException.

    üëâüèª Almost all the implementations of the iterator, are fail-fast by design.
      ** Except the concurrent collection classes.

What are Concurrent Collection classes? When does ConcurrentModificationException occur?
    The Concurrent Package [java.util.concurrent] which introduced in java 1.5,
    contains thread-safe collection classes called Concurrent Collection class:
    -> that allows collections to be modified while iterating.

    By design, iterator implementation are fail fast and throw the ConcurrentModificationException
    whenever we modify element while iterating.

    -> Iterator implementations in Concurrent Package allows us to do the modifications at runtime too.

    1. CopyOnWriteArrayList 2. ConcurrentHashMap 3. CopyOnWriteArraySet.

What is the difference between fail-fast and fail safe?

What is the difference between Synchronized Collection and concurrent collection?
    Synchronized collections classes, like Hashtable and Vector provides thread-safe implementation of Map
    and List.

    There are several factors which make them less suitable for use in highly concurrent applications.

    Performance: The synchronized collections are unsuitable because of their 'wide-locking mechanism'.
    They acquire lock on complete object whereas concurrent classes locks only a part.

When do we use ConcurrentHashMap in Java?

Can we replace HashTable with ConcurrentHashMap?
    Yes, we can replace the HashTable with ConcurrentHashMap.
    -> As the performance of ConcurrentHashMap is better than HashTable.

    We need to be careful with code which relies on locking behavior of Hashtable.
    Since Hashtable locks whole Map instead of a portion of Map, compound operations like
    if(Hashtable.get(key) == null) put(key, value) works in Hashtable but not in concurrentHashMap.

What is CopyOnWriteArrayList? How it is different than ArrayList?
    <lecture>

What is BlockingQueue?
    <lecture>
	
	
	
What is a design pattern ?
    Design patterns is the basket of pre-designed solutions to common problems in Object Oriented programming
    given by various programmers in the world.
    They promote reusability which leads to a more robust and maintainable code.

In how many catogories Design Patterns are classified?‚≠êÔ∏è
    The Design patterns can be classified into three main categories:
    Creational Patterns
    Structural Patterns
    Behavioral Patterns

A Class Instance Can Be Created Using New Operator. Why Should We Use Creational Design Patterns To Create Objects?‚≠êÔ∏è

    In scenarios where the nature of the object can change according to the nature of the program,
    that is where we are not sure about which class's object we are going to create each time.
    we use creational design patterns which offer flexible approach for creating class instances.

Which Object Oriented Method Is Used By The Creational Patterns To Instantiate Object?
    Creational patterns use inheritance.

What is Singleton Pattern in Java?‚≠êÔ∏è
    Singleton pattern is a creational pattern which allows only one instance of a class to be created
    which will be available to the whole application.
    The major advantage of Singleton design pattern is that it always saves memory because
    the single instance is reused again and again. There is no need to create a new object at each request.
    For example, we can use a single database connection shared by multiple objects,
    instead of creating a database connection for every request.

    Java.lang.Runtime is a classical example of Singleton design pattern

How can we create thread-safe singleton in Java?
    There are multiple ways to write thread-safe singleton in Java
    e.g
    by writing singleton using double checked locking,
    by using static Singleton instance initialized during class loading.
    By using Java enum to create thread-safe singleton is most simple way.

What are the drawbacks of using singleton design pattern?
    The major drawbacks of using singleton design pattern are:
    a)Singleton causes code to be tightly coupled.

    b)They hide dependencies instead of exposing them.

    c)Singleton Pattern does not support inheritance.

    d)Singleton principle can be violated by techniques such as cloning.

How To Prevent Cloning Of A Singleton Object?
    Throw exception within the body of clone method.

Why and When Will You Use A Factory Pattern?
    Why:
    Factory classes provide flexibility in terms of design. Below are some of the benefits of factory class:
    ‚Ä¢Factory design pattern results in more decoupled code as it allows us to hide creational logic from dependant code
    ‚Ä¢It allows us to introduce an Inversion of Control container
    ‚Ä¢Factory pattern‚Äôs main benefit is increased level of encapsulation while creating objects.
    If you use Factory to create object you can later replace original implementation of Products or classes
    with more advanced and high performance implementation without any change on client layer.

    When:
    - a class does not know which objects of class it must create
    - factory pattern can be used where we need to create an object of any one of sub-classes depending
    on the data provided

What is the difference between factory and abstract factory design pattern?‚≠êÔ∏è
    Both factory and abstract factory are creational design patterns.

    The major difference between these two is, a factory pattern creates an object through inheritance
    and produces only one Product.
    On the other hand, an abstract factory pattern creates the object through composition
    and produce families of products.

What is observer design pattern in Java? When it is used?
    Observer design pattern is one of the behavioral design patterns
    which defines one-to-many dependencies between objects & is useful
    when we are interested in a state of an object and
    we want to get notified when there is any change in state of Object.
    In Observer design pattern, when one object changes its state,
    all its dependent objects are automatically notified,
    the object is called Subject and dependants are called Observers.
    Java provides libraries to implement Observer design pattern using java.util.Observable class
    & java.util.Observer interface.

Which design pattern will you use to create a complex object?
    Builder design pattern is used to construct a complex object.
    It is designed to solve the issues with factory and abstract design pattern.

Give example of decorator design pattern in Java ? Does it operate on object level or class level ?‚≠êÔ∏è

    The decorator pattern, also known as a structural pattern is used to add additional functionality
    to a particular object at runtime. It wraps the original object through decorator object.
    For example, when you are buying a burger, you can customize it by adding extra filling and sauces,
    now the cost of these items have to be added to the final price.
    The customization will differ from customer to customer and offer from a shop.
    Creating different classes of burger with different fillings will end up creating a lot of classes.
    Decorator solves this problem by extending the functionality of single Burger class at runtime based
    on customer request.

What is the benefit of using prototype design pattern over creating an instance using the new keyword?‚≠êÔ∏è
    Sometimes, object creation is heavyweight and requires a lot of resources,
    creating a new instance will impact the performance.
    In such cases, a prototype design pattern is used which refers to creating duplicate objects.
    In prototype design pattern, if a similar object is already present then
    cloning is done keeping performance in mind.

What is MVC design pattern ? Give one example of MVC design pattern ?
    MVC stands for Model-View-Controller Pattern. We can use this pattern for better organization of code.

    Model : Model layer is layer which interacts with datdabase. Model is the data layer.
    So, The model is responsible for managing the data of the application.

    view : The view means presentation of the model in a particular format.
    It is what the user interacts with (the Front-end ).

    Controller : user request first enters the controller  .
    Controller works between model and view..
    The controller responds to the user input and performs interactions on the data model objects.
    The controller receives the input, optionally validates it and then passes the input to the model.

What is FrontController design pattern in Java ? Give an example of front controller pattern ?
    The FrontController Design Pattern provides a centralized request handling mechanism
    so that, all the requests are handled by a single handler.

    FrontController is a centralized entry point for handling requests.

    So FrontController pattern is generally used to do the authentication or authorization or tracking of request and
    then pass the requests to corresponding handlers using the Dispatcher.
    FrontController redirects the request to dispatcher and dispatcher identifies the handler which can handle the request

What is Chain of Responsibility design pattern ?
    the chain of responsibility pattern creates a chain of receiver objects for a request.
    It is one of the behavior pattern in which a objects are chained together in a sequence.
    and a responsibility or we can say a request is provided in order to be handled by the group
    that means it decouples sender and receiver of a request based on type of request.
    So, In this pattern, normally each receiver contains reference to another receiver.
    If one object cannot handle the request then it passes the same to the next receiver and so on.

What is Adapter design pattern ?
    Adapater is actully used to facilitate the communication between two subjects,
    when they are not able to understand each other.

    Adapter design pattern works as a bridge between two incompatible interfaces.
    This pattern involves a single class called adaptor between two incompatible interfaces.

    Or

    Adapter allows two classes of a different interface to work together,
    without changing any code on either side.

Difference between strategy and state design pattern in Java?‚≠êÔ∏è
    Strategy Design Pattern :
    Strategy design pattern used when we have multiple solution or algos to solve a specific task
    and at runtime client decides the specific implementation which is to be used.

    The Strategy pattern suggests keeping the implementation of each of the algorithms in a separate class.
    Each such algorithm encapsulated in a separate class is referred to as a strategy.
    An object that uses a Strategy object is often referred to as a context object.


    State Design Pattern :
    State design pattern used to alter an object's behaviour when its internal state changes.
    State Design pattern is useful,
    in the case of an object of a class that has some or all of its behaviour completely influenced
    by its current state or internal state.
    and that class is referred to as a Context class.
    A Context object can alter its behaviour when there is a change in its internal state and
    is also referred as a Stateful object.

What is null Object Pattern?
    In Null Object pattern, a null object replaces check of NULL object instance.
    Instead of using a null reference to convey absence of an object (for instance, a non-existent customer),
    one uses an object which implements the expected interface, but whose method body is empty.
    The advantage of this approach over a working default implementation is that
    a null object is very predictable and has no side effects: it does nothing.

Can you name few design patterns used in standard JDK library?‚≠êÔ∏è

    Builder
    java.lang.StringBuilder#append()

    Factory method
    java.util.Calendar#getInstance()

    Prototype
    java.lang.Object#clone() (the class has to implement java.lang.Cloneable)

    Singleton
    java.lang.Runtime#getRuntime()
    java.lang.System#getSecurityManager()

    Decorator
    All subclasses of java.io.InputStream, OutputStream, Reader and Writer
    have a constructor taking an instance of same type.

    Observer (or Publish/Subscribe)
    All implementations of java.util.EventListener (practically all over Swing thus)

What Are J2ee Patterns?
    These design patterns are specifically concerned with the presentation tier.
    These patterns are identified by Sun Java Center.
	
	
	
//Design Principles

What are Software Design Principles?
    Software design principles represent a set of guidelines that helps us to avoid having a bad design.
    According to Robert Martin there are 3 important characteristics of a bad design that should be avoided:
      - Rigidity
      - Fragility
      - Immobility


What are SOLID principles?
    S -> Single Responsibility Principle
    O -> Open/closed Principle
    L -> Liskov substitution principle
    I -> Interface Segregation Principle
    D -> Dependency Inversion Principle.
	
	
	
What is Exception in Java?‚≠êÔ∏è
    Exception is an error event that can happen during the execution of a program
    and disrupts it‚Äôs normal flow.

What is the difference between Exception and Error?
    An Error "indicates serious problems that a reasonable application should not try to catch."
    An Exception "indicates conditions that a reasonable application might want to catch."

What are Compile Time Errors, Compile Time Exception, Runtime errors and Runtime Exceptions ?‚≠êÔ∏è‚≠êÔ∏è
   So on this question let me be very specific..because a lot of people get confused when they listen these terms .
   If you see the exception heirarchy
   all the classes are child of Throwable and see..we have Exception and error.

What is difference between Checked and Unchecked Exception in Java ? Explain Exception heirarchy.
    Main difference between Checked and Unchecked Exception lies in their handling.
    Checked Exception requires to be handled at compile time using try, catch and finally keywords
    or else compiler will flag error.
    This is not a requirement for Unchecked Exceptions.
    Also all exceptions derived from java.lang.Exception classes are checked exception,
    exception those which extends RuntimeException, these are known as unchecked exception in Java.
    You can also check next article for more differences between Checked and Unchecked Exception.

    All Exceptions are Java Objects and falls under Throwable class.
    Other than the exception class there is another subclass called Error which
    is derived from the Throwable class.
    Errors are abnormal conditions that happen in case of severe failures, these
    are not handled by the Java programs.
    For example the Exception class has these subclasses:
    IOExceptionclass, AWTException class, SQLException class,
    InterruptedExceptionclass and RuntimeException Class.

    Again Note that : Errors are also unchecked Exceptions because we can't handle them.‚≠êÔ∏è

What is similarity between NullPointerException and ArrayIndexOutOfBoundException in Java?
    Both of them are example of unchecked exception and derived form RuntimeException.

Which of the following combinations are correct or incorrect?

What is difference between throw and throws keyword in Java?
    throw keyword is used to throw exception explicitly from any method or static block
    while throws keyword is used in method declaration, it denotes which exception can possiblly be thrown by this method.
    throw is followed by an instance while throws is followed by exception class name.

How exception is propagated? What is default exception handling?‚≠êÔ∏è
    An exception is first thrown from the top of the stack, if it is not caught,
    it drops down the call stack to the previous method and so on until they are caught or until they reach the very bottom of the call stack that means up to main method.
    This is called exception propagation.

What is Exception chaining in Java?
    Exception chaining is a popular exception handling concept in Java,
    where another exception is thrown in response of an exception and creating a chain of Exceptions.
    This technique mostly used to wrap a checked exception into an unchecked or RuntimeException.

How to write custom Exception in Java?why we use custom or user defined exceptions?‚≠êÔ∏è
    Customized exceptions or user defined exceptions are the exceptions which are created by Programmer to achieve programming requirements.
    In java we can create our own exceptions, by creating class under Exception hirearchy, and throw them on a particular condition.
    We can define exceptions checked or unchecked, by extending Exception or RuntimeException.
    Making custom exception checked, will bound us to handle those exceptions.
    And if Custom exception are unchecked, we can simply throw them, hence these exceptions should be defined as unchecked.

Does code form finally executes if method returns before finally block or JVM exits ?
     finally block in Java executes even when return keyword is used in try block.
     but when you call System.exit(0) from try block, it will not execute.

What is difference in final, finalize and finally keyword in Java?‚≠êÔ∏è
    Final class can't be inherited,
    final method can't be overridden and
    final variable value can't be changed.

    Finally is used to place important code,
    it will be executed whether exception is handled or not.

    Finalize is used to perform clean up processing just before object is garbage collected.

What is the purpose of using multiple catch Blocks? can we catch Exception before FileNotFoundException?
    We can catch different exceptions by using multiple catch blocks in a proper hierarchy.
    For example you have to handle more than one Exception
    that may be thrown from the code written inside the try block,
    then that can be handled by two diff catch blocks,

    we can not catch exception first because its higher in heirarchy than FlieNotFoundException.
    So we catch the most specific first.
    In case, there is not parent-child relation or if Exceptions we are catching are at same level in heirarchy
    then order does not matter.

What is Java 7's multi-catch block?
    if we catch a lot of exception in a single try block, the catch block code looks very ugly,
    That is why, to reduce length of code,
    we can use a single catch with multiple exception seperated by single pipelines if handling for all of
    those exceptions is going to be same.
    This is taken as an improvent or enhancement in java 1.7.
    Hence, Single catch block can be written to handle different type of exceptions
    and it is called multi-catch block.

What is Java 7's automatic resource management Feature?‚≠êÔ∏è
    Basically try with resources is a try statement that declares one or more resources.
    It ensures that each resource that we used in our program is closed at the end of try block.
    so it is like an alternate of finally block, which we use for the same purpose.
    In ARM We are not responsible to close the resource.

What best practices you follow while doing Exception handling in Java ?‚≠êÔ∏è
    1. is To clean up the resources gracefully after using them.
    2. Always correctly wrap the exceptions in custom exceptions so that stack trace is not lost
    3. Exception handling should be used wisely -no overuse
    4. we can Either log the exception or throw it but never do the both.
    5. Logging Exception
    6. define exception handling strategy at the design time
    7. Know when to Throw checked and when to throw unchecked exception
    8. Throw exception as early as possible
    9. Catch late / catch as early as we know how to handle the issue properly

    DeliverGifts
      packGifts
        giftSelector
          GiftManufecturer

What is wrong with following code in Java:

    public class SuperClass {
        public void start() throws IOException{
            throw new IOException("can't operate on file");
        }
    }

    public class SubClass extends SuperClass{
        public void start() throws Exception{
            throw new Exception("Not able to start");
        }
    }

    In this code compiler will complain on sub class where start() method gets overridden.
    As per rules of method overriding in Java, an overridden method can not throw Checked Exception
    which is higher in hierarchy than original method.
    Since here start() is throwing IOException in super class, start() in sub class can only
    throw either IOException or any sub class of IOException but not super class of IOException e.g. Exception.

What is wrong with following Java Exception code:

    public static void start(){
       System.out.println("Executing start!");
    }

    public static void main(String args[]) {
       try{
          start();
       }catch(Exception e){
          e.printStackTrace();
       }
    }

    IOException is a checked Exception
    and start() method doesn't throw IOException,
    so compiler will flag error as "exception java.io.IOException is never thrown in body of corresponding try statement",
    but if you change IOException to Exception compiler error will disappear
    because Exception can be used to catch all RuntimeException which doesn't require declaration in throws clause
    because compiler can not check for RuntimeExceptions.
	
	
	
=================================


What is Generics in Java ? why we should use Generics?‚≠êÔ∏è
    //benefits of using Generics?
    Simply stating generics is a mechanism for type checking at compile time
    Code that uses generics has many benefits over non-generic code:

    1) Stronger type checks at compile time:
    A Java compiler applies strong type checking to generic code
    and issues errors if the code violates type safety.
    Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.

    2) Code Reusability

    3) Elimination of casts:
    prior to Java 5 , to get the element back from collection we had to cast it back to correct Type before using it.
    But now If you use generics, then explicit type casting is not required anywhere.

    4) Enabling programmers to implement generic algorithms:
    By using generics, programmers can implement generic algorithms that work on collections
    of different types, can be customized, and are type safe and easier to read.

Which exception we get if we cast an element to wrong type?
    ClassCastException

Can we generify a static method? Can we have a static varible of generic type?
    NO.

What are generic types?
    A generic type is a generic class or interface that is parameterized over types.

Can a generic type extend or implement a non-generic type?
    Yes.

    public class GenericClass<T> extends NonGenericClass{

    }

    public class GenericClass<T> implements NonGenericInterface{

    }

    public class GenericClass<T> extends RawTypeClass{

    }

    public class GenericClass<T> implements RawTypeInterface{

    }

Can a non-generic type extend or implement a generic type?
      Only if we parametrize the with a specific type.

      public class NonGenericClass extends GenericClass<T>{    ‚ùå

      }

      public class NonGenericClass extends GenericClass<String>{  üíØ

      }


      public class NonGenericClass implements GenericInterface<T>{ ‚ùå

      }

      public class NonGenericClass implements GenericInterface<String>{  üíØ

      }

What is a Raw-Type?‚≠êÔ∏è
    Raw-Type is a generic-type without any type argument.
    ArrayList l = new ArrayList();

Difference between List<String> and raw type List.‚≠êÔ∏è
    List listOfRawTypes = new ArrayList();
    listOfRawTypes.add("abc");
    listOfRawTypes.add(123); //compiler will allow this - exception at runtime
    String item = (String) listOfRawTypes.get(0); //explicit cast is required
    item = (String) listOfRawTypes.get(1); //ClassCastException because Integer can not be cast in String

    List<String> listOfString = new ArrayList<>();
    listOfString.add("abcd");
    listOfString.add(1234); //compiler error, better than runtime Exception
    item = listOfString.get(0); //no explicit casting is required - compiler auto cast

Can a generic Type have more than 1 type parameters?‚≠êÔ∏è
    yes,  We can create classes having mutiple type parameters.
    a generic type can have multiple type parameters.
    Example: Hashmap<K,V>

Can we add elements of subtype to an object of super type?‚≠êÔ∏è
    //Type compatibility  //Substitution Principle
    Yes , if the types are compatible, you can add the elemets or objects.
    Example:
    List<Number> l = new ArrayList<>();
    you can add integer to it. Because Integer is sub-type of Number.

Is sub-typing possible in java?‚≠êÔ∏è‚≠êÔ∏è
    //sub-typing
    As long as you do not vary the type argument, the subtyping relationship is preserved between the types
    else there is no such thing as sub-typing.

    ArrayList is a sub Type of List.

    List<Integer> list = ArrayList<Integer>();
    So,
    ArrayList<Integer> is also a SubType of List<Integer>
    because types are same.
    But,

    List<Number> list = ArrayList<Integer>();   ‚ùå
    ArrayList<Integer> is not a sub type of List<Number>.

    Also,
    ArrayList<Number> al = Arraylist<Integer>(); ‚ùå
    As we know this is also Not possible, Both Type Arguments should be same.

How to write a generic method? When should we use generic method?‚≠êÔ∏è

    public <T> void GenericMethod(List<T> l){

    }
    When the class does not have multiple area to use the type parameter,
    i.e., when we are not needed to generify the whole class then we can generify the perticular method only.

Can we generify constructor?
  As constructors are also special kind of methods, we can generify them.

Can we use Generics with Array?
    No.

What are bounded types? How to Bound a Type parameter?‚≠êÔ∏è
    There may be times when you'll want to restrict the kinds of types
    that are allowed to be passed to a type parameter.
    For example, a method that operates on numbers might only want to accept instances
    of Number or its subclasses. This is what bounded type parameters are for.

    To declare a bounded type parameter,
    While creating a generic type or a generic method,
    list the type parameter's name, followed by the extends keyword, followed by its upper bound.

    <Name extends UpperBound>


    Class:

    class MyClass<T extends Number>{}

    Interface:

    interface MyInterface<T extends Number>{}

    Method:

    public <T extends Number> void method(List<T> li){

    }

What is type inference?‚≠êÔ∏è
    Type inference is a Java compiler's ability to look at each method invocation and corresponding
    declaration to determine the type argument (or arguments) that make the invocation applicable.
    The inference algorithm determines the types of the arguments and, if available, the type that
    the result is being assigned, or returned. Finally, the inference algorithm tries to find the
    most specific type that works with all of the arguments.

What are Wild Cards in generics?‚≠êÔ∏è
    In generic code, the question mark (?), called the wildcard,
    It represents an unknown type.
    The wildcard can be used in a variety of situations:
    as the type of a parameter, field, or local variable; sometimes as a return type
    (though it is better programming practice to be more specific).

What is Bounded and Unbounded wildcards in Generics ?
    <?> represent unbounded type where there is no bound.

    Bounded Wildcards are those which impose bound on Type.
    there are two kinds of Bounded wildcards
    <? extends UpperBound> which impose an upper bound by ensuring that type must be sub class of UpperBound class and
    <? super LowerBound> where its imposing lower bound by ensuring Type must be super class of LowerBound class.

Can we have more than one Bound?
  With type parameters we can have more than one bound but with wildCards we can not.

What are the restrictions on wildcards?

can we use Type parameters and wildcards as return type?
  yes. But wildcard can not be used as the direct return type.

How Generics works in Java? What is type erasure?‚≠êÔ∏è

Can you pass List<String> to a method which accepts List<Object>
    No,

    List<Object> objectList;
    List<String> stringList;

    objectList = stringList;  //compilation error incompatible types

Difference between List<Object> and raw-type List in Java?
    Main difference between raw type and parametrized type List<Object> is that,
    compiler will not check type-safety of raw type at compile time but it will do that
    for parametrized type and by using Object as Type it inform compiler that
    it can hold any Type of Object e.g. String or Integer.

Difference between List<?> and List<Object> in Java?
    List<?> is List of unknown type while List<Object> is essentially List of any Type.
    You can assign List<String>, List<Integer> to List<?> but you can not assign List<String> to List<Object>.

    List<?> listOfAnyType;
    List<Object> listOfObject = new ArrayList<Object>();
    List<String> listOfString = new ArrayList<String>();
    List<Integer> listOfInteger = new ArrayList<Integer>();

    listOfAnyType = listOfString; //legal
    listOfAnyType = listOfInteger; //legal
    listOfObjectType = (List<Object>) listOfString; //compiler error - in-convertible types
	
	
	=======================================================================
	
	
What is Inner class?
    Any Class which is not a top level Class or any Class which is declared inside another Class
    is Inner class.

    class OuterClass{
    	class InnerClass{
    	    public void display(){
            System.out.println("Inner class.");
          }
    	}
    }

What are the types of Inner classes?‚≠êÔ∏è
    There are following types of such classes:
    1. Member Inner class | Regular Inner class
    2. Local Inner class
    3. Anonymous Inner Class
    4. Static Nested Class

What is Member Inner Class?‚≠êÔ∏è
    Member Inner Class is just regular inner Class which is not static member of the outer class.
    It acts as other instance member of that class.

    class OuterClass{
      class InnerClass{
          public void display(){
            System.out.println("Inner class.");
          }
      }
    }

    -> Class Inner behaves as instance member of this Class Outer.
    -> To access this class, we must create the object of Outer Class.

    The Member inner classes can be private protected public final <default> abstract etc.

What is the difference between Static nested Class and Member Inner class?‚≠êÔ∏è

    Static Nested Class is the Class which is declared inside another Class with static modifier.

    class Demo{
    	static class Nested{
    		public void method(){
          System.out.println("Static Nested class.");
        }
    	}
    }

    üëâüèª To create the instance of Member Inner class, an instance of Outer Class is required.
      Whereas static nested Class does not require any outer Class instances. It can be Accessed just
      like other static members of that class.

    Demo.Nested obj = new Demo.Nested();
    Obj.method();

    üëâüèª In Member Inner class/ Non-static Nested class, we can access all the static and instance variables of the outer class.
       Whereas, inside static nested class, we can only access the static variables of outer class.

    üëâüèª We can not declare static methods inside Regular inner classes whereas in static nested classes,
       we can do so.
       So we can declare main method in static nested class, whereas in regular inner classes we cannot.

    üëâüèª We can Import Nested Static Class with static import, whereas we normally Import the non
       static nested classes.

What are Local Inner Classes?‚≠êÔ∏è
    Local inner classes are those classes which are declared inside a code block or a method.

    class Main{
    	private String info = "Outer Class Member";

    	public void method1(){
    	   class Printer{
    		public void printInfo(){
    			System.out.println(info);
    		}
    	   }
    	}
    }

    -> Local inner classes can be used to define specific required functionality for that particular method.

    üëâüèª Local Inner Class is a member of the method, so their scope is limited to that particular
       method only; Local inner classes are the most rarely used inner classes.

Can we access local variable of the wrapping method inside local inner class?
    Yes, we can access final or non-final local variables in local inner class, But We can not modify them.
    If we Try to modify them, compiler will raise error.

What access modifiers can be used with Local inner classes?
    Local inner is the local member of method, so it can not be declared as public private protected.
    üëâüèª Local inner classes can only be final or abstract.

What is Anonymous Inner class?‚≠êÔ∏è‚≠êÔ∏è
    Anonymous Inner Class is a Class which does not have name to reference and initialised at the same
    place where it gets created.
    üëâüèª For anonymous inner classes, only a single object is created.

    Note: An Anonymous Inner Class always extend a Class or implement an interface.

When should we use Anonymous inner classes?
    -> An Anonymous Inner Class can be used while making an instance of an object with certain additional
    functionalities such as overloading methods of a class, or interface, without having actually any
    subclass.

    For example, Anonymous inner classes are common to extend Thread Class in order to override run method.

    Similarly we can also create anonymous inner class, by implementing runnable interface.

    -> Also Anonymous inner classes can be frequently used in GUI based applications for event handling.
       We can write implementation classes for listener interfaces in graphics programming using them..

Can we create constructor in anonymous inner class?
    We know the constructor has the same name as of the class. We can create constructor explicitly in
    all other types of inner classes and static nested class.

    But in the case of Anonymous inner class, we do not have the name of the class.
    üëâüèª We cannot write any constructor explicitly in anonymous inner class.

What are differences between an Anonymous Inner Class and a normal class?
    Both are different in many ways:

    1. A normal Class can extend one Class and implement many interfaces at the same time, whereas
       the Anonymous Inner Class can either extend one Class or implement one Interface at a time.

    2. We write constructors in normal class, which are invoked at the time of instance creation.
       But we cannot write any constructor in anonymous inner class.
       üëâüèª These classes are initialised at the time of creation itself with the default constructor.

    3. We write normal classes for our standard requirements whereas we write anonymous inner classes
       when we do not need any separate Class for some temporary requirements,
       or when we need to provide implementations to methods for a single object.

Can we have static members inside anonymous inner classes?
    No, we cannot declare static data members or static member function inside anonymous inner class.
      -> In-fact we can not define any static member inside any inner class. we can do so only in
      Static nested classes.

What are the ways of creating Anonymous inner classes?‚≠êÔ∏è
    Ways to Create anonymous inner classes,
    1. By extending a class:

        Thread t = new Thread(){
      		public void run(){
      			System.out.println("Anonymous inner Thread");
      		}
      	  };
      	t.start();

    2. By implementing an interface:

      	Runnable r = new Runnable() {
      		@Override
      		public void run() {
      			System.out.println("Runnable");
      		}
      	} ;
      	Thread th = new Thread(r);
      	th.start();

    3. Defining inside any method or constructor argument:

      	Thread t = new Thread(new Runnable(){
      		public void run(){
          			System.out.println("Child Thread");
      	}
      	}}).start();

What are the advantages of inner classes?
    We use nested Class when it is useful to only one class. So keeping them together helps in the
    packaging of the classes.

    By using Inner classes we develop more readable and maintainable code, because it logically
    groups the classes in one place.

    With inner classes we can access outer Class private members and at the same time we can hide
    inner Class from the outer world. Inner classes implements encapsulation.

    We also optimize the code by writing inner classes as it requires less code to write.

Can we write Nested Interface inside an Interface?
    Answer is Yes.
    When an Interface is required for one Interface only then we may write Interface inside Interface.

    for example,
    In Map Interface we have the Interface Entry, which is used for Map only.
    Entry represents a key-value pair inside map.

    üëâüèª The inner interfaces which are declared inside Interface are always public and static,
       even if we do not make them public or static explicitly.

    üëâüèª Inner interfaces can be implemented independently.

Is it possible to define Interface inside Class or Class inside interface?
    Answer is Yes. Both cases are possible.

    If we define Interface inside class, it is always static.
    We can declare it as private public or protected according to our requirement.

          class Demo{
          	public interface Inner{
          	}
          }

    And if any Class is closely associated with any Interface then it may be defined inside the interface.

    For example, class EmailDetails is required for the interface EmailService.
    So we can define it inside this interface.

        interface EmailService{
        	public void sendMail(EmailDetails e);
        	class EmailDetails{
        	..
        	..
        	}
        }

    Note: If we implement the Interface with its own inner Class then it is called as its default implementation.
	
	
	=========================================================================================
	
	-----JVM----

L1-00:40 What do you mean by Virtual Machine?
    A software program that simulates behaviour of a physical machine, which can perform operations
    like any other physical machine. For example,
    -> VMWare is the system based virtual machine
    -> JVM is the Application based virtual machine

L1-01:17 What is JVM?
    "Java Virtual Machine"
    Basically JVM provides runtime environment in which Java programs are executed.
    First the java programs get compiled and converted into byte code.
    JVM is responsible for loading Class files and executing that byte code.

-> What makes Java platform independent? Or what you mean by 'write once, run anywhere'?‚≠êÔ∏è
    JVM converts the byte code to the machine specific code i.e,
    one java program can be executed on any type operating system because of JVM.
    That is why we need different kinds of JVM for different Operating systems.

L1-02:36 Is JVM, a compiler or interpreter ?‚≠êÔ∏è
    JVM is an interpreter.

L1-02:45 What are JRE, JDK? how these are different from JVM?‚≠êÔ∏è
    JRE: JRE stands for Java runtime environment and JVM is actually an implementation of JRE.
    It consists of set of libraries like jar files and other files that JVM uses at runtime.
    so it is different from JVM as it only contains the environment to execute java program.

    JDK: The Java development kit consists more than JRE, as it provides all the tools which
    are used to develop java applications along with tools and executable required to compile,
    debug and execute java program.

L1-04:25 How JVM works?‚≠êÔ∏è
    We know, JVM is a runtime engine to run the java applications.. when we write a java file..
    the compiler creates the Class file having the byte code.. This .class file goes into various steps.

L2-00:17 What is Classloader?‚≠êÔ∏è
    Class loader is a set of components which loads the classes during runtime into JVM.
    These classes are not loaded all at once, when the application requires that particular class or we can say
    when we try to use a Class, Java ClassLoader loads that class into memory.

L2-00:43 What activities are performed by the classloader subsystem?
    Class loader subsystem is responsible to perform these three activities:
	     1.Loading
	     2.Linking
	     3.Initialization

       Loading: The classloader reads the class and generates the binary data.
       This binary data get stored inside method area.
                Method area - class related data gets stored.
       With all the class info, JVM creates an object of Type : java.lang.Class for that loaded class in
       heap area.
       This 'java.lang.Class' class object provides complete information for that class.

02:30  -> If we call a class more than once, will there be more than one java.lang.Class object for that
       class?
            NO. Even though we call the class multiple times but in the heap area there will be only one
            Class class object, because one Class class object for that particular class is enough to
            provide information for that class. For any new object the class information will remain same.

        Linking: It consists of three activities..
                Verify
                Prepare
                Resolve

            Verification: Bytecode verifier ensures that code passed to java interpreter is in a fit state
            to be executed.
            This is also a reason why JAVA is secure..

            Preparation: JVM allocates memory to class level variables and assign default values to them.

            Resolution: JVM replaces symbolic names with original memory references from method area.
                        class Demo{
                          public static void public static void main(String[] args) {
                            String s = ...
                            Student s1 = new Student();
                          }
                        }

                    Constant Pool of Demo : Demo, String, Student
              In resolution, these names will get replaced with memory level references from method area.

        Initialization: -> Original value get assigned to the static variables.
                        -> Static blocks get executed from parent to child and top to bottom in this phase.

        Note: While loading linking initialisation any error occurs,
        then we will get runtime exception saying java.lang.linkage error.

L2-07:14 What are the different class loaders used by JVM?
    There are three diff class loaders, each of them has a predefined location from where they loads class.

    Bootstrap Class Loader | Primordial Class loader:

        It is responsible to load the classes which are present in bootstrap path (jdk->jre->lib->rt.jar)
        like, rt.jar..
        rt.jar -> core java apis.
        so this Class loader loads the core java api classes.

        This Class loader is parent of all other class loaders in java. It is not implemented in java.

    Extension Class Loader:

        This Class loader is responsible to load classes from the extension path. (jre/lib/ext/'*'.jar)
        Extension Class loader is the implementation of Bootstrap Class loader.
        It is implemented by sun.misc.Launcher$ExtClassLoader

    Application Class loader | System Class loader:

        It is responsible for loading the classes from the CLASSPATH environment variable.
        This is the child class of Extension Class loader.
        It is implemented by sun.misc.Launcher$AppClassLoader.

    Note: Except the bootstrap classloader which is only implemented in native languages not in java,
    all the classloader are implemented using java.lang.ClassLoader.

L2-09:28 How does JVM load the classes?‚≠êÔ∏è
    The classloader subsystem works on the delegation principle. One classloader delegates the
    responsibility for loading the class to their parent and if it doesn't work, then they loads the class
    by themselves

 What is the difference between static and dynamic class loading?‚≠êÔ∏è

L2-12:30 What is difference between Class.forName() and ClassLoader.loadClass()?‚≠êÔ∏è
    Both methods try to load classes dynamically.

    The most common method is Class.forName(). By default the classes get initialised using this method.

    loadClass() is an instance method and requires a particular ClassLoader to load the class.

    By default the classes does not get initialised in this.

//Memory Areas
L3-00:12 What are the various memory areas present in JVM?‚≠êÔ∏è
    JVM has 5 different memory areas ..
    1. Method area
    2. Stack area
    3. Heap area
    4. PC Registers
    5. Native method area

L3-00:30 Which memory area is used to store Static variables?
    JVM stores the Class level information in the Method area.
    Class level information consists Class name, parent Class name, Method info, Variables info,
    Constructors, Modifiers info, Constant pool info etc.

    Whenever we start JVM, a method area gets created,
    üëâüèª and that will be shared among all JVM threads.

L3-01:14 When are the static variables loaded in memory?
    Static variables get loaded at the time of Class loading and gets stored in the method area.

L3-01:31 What is Heap space in Java?‚≠êÔ∏è
    Heap memory in JVM is used to store objects and corresponding instance variables.
    üëâüèª Whenever we create objects, it is always created in Heap space.

    Heap area gets created when we start JVM
    üëâüèª Heap area is shared among all the threads.

    Method and heap area need not be continuous.

L3-02:10 What is String pool?‚≠êÔ∏è
    String pool or string intern pool is a special storage area in Heap space.
    When we create a string, it gets stored to the string pool, so that if any other string will get
    created which exists in the pool then instead of creating new object,
    the reference of existing string will be returned.

L3-03:04 What is Stack? What it stores?‚≠êÔ∏è
    Stack is a part of memory that stores each method call performed by that thread including primitives
    and local variables.

    üëâüèª For every thread, a new runtime stack gets created..

L3-05:42 What is stack frame? What does it consist?
    Each entry in stack is called stack frame.
    1. Local Variable Array
            -> Which store local variables and corresponding values related to any method.
    2. Operand Stack
            -> It is a runtime workspace for JVM, to perform any intermediate operations.
    3. Frame data
            -> All symbols corresponding to any method are stored here.

    üëâüèª For every method call one stack frame is created.

How stack and heap are interrelated?‚≠êÔ∏è
    We know Local variables are stored on the stack, and all the objects in java are stored on the
    Heap area.
    üëâüèª For every object on the heap, there is a pointer which is the reference to that object.
    This reference variable is also stored on the stack. This is how Stack and heap are interrelated..

How to get information about heap memory?
    We know the java application can communicate directly with JVM via runtime class.
    Runtime Class provides various methods from which we can get information about memory.

    We create Runtime instance via method getInstance(), because this Class is Singleton class.

    Runtime r = Runtime.getInstance();
    r.maxMemory();
    //this method returns the maximum amount of memory that the Java virtual machine will attempt to use.

    r.totalMemory()		//this returns the total amount of memory in the Java virtual machine.

    r.freeMemory();		//this returns the amount of free memory in the Java Virtual Machine.

What happens when there is not enough Heap Space for storing new objects?‚≠êÔ∏è
    JVM tries to free up space but if it fails then JVM throws java.lang.OutOfMemoryError.

How to set minimum and maximum heap size??
    By using -Xmx we can specify the maximum heap size for any program..
    And -Xms to set the minimum heap size..

    $ java -Xms512m -Xmx1024m <classname>

Why do member variables have default values whereas local variables do not have any default value ?
    In java, ClassLoader is responsible to load the Class and while loading the Class they initialize
    the static variable and blocks.

    JVM does not have any idea about local variables at the time of Class loading, therefore
    local variables do not have any default values.

What PC registers are for?
    üëâüèª Every thread has separate PC register.
    PC registers is used to hold the address of current executing instruction. when the instruction gets
    executed the PC register will be updated with the next one.

What is Native Method Stack?
    It is another memory space of JVM which stores the native method information.
    üëâüèª for every thread, there will be a separated native method stack.

//Execution Engine

What is Execution engine? What it does?
    Execution engine is the component in JVM which is responsible to execute the byte code which is
    assigned to the runtime data area.

    It has following sub-components:
    1. Interpreter
    2. JIT compiler
    3. Garbage collector

What is Interpreter?
    Interpreter is a program that reads byte code in the sequential manner (line by line).
      it runs the application by accepting file name argument from the command line,

      java <compiled file name>

What are the limitations interpreter has?
    Interpreter interprets fast but executes slow!
    The limitation is, when a code of block or one method is called multiple times,
    every time a new interpretation is required.

What is JIT compiler?‚≠êÔ∏è
    It stands for Just-in-time compiler.
    It compiles those byte code parts which are having similar functionality at the same time.

Sub components of JIT compiler:
    1. Intermediate code generator: it produces intermediate code.
    2. Code Optimizer: Responsible for optimizing that intermediate code.
    3. Target code generator: Responsible for generating native code!
    4. Profiler: Responsible for finding the hot code! It finds which method is called multiple times.

What is Garbage collector?
    It is the component of Execution engine which frees up the memory by collecting and removing
    the unreferenced objects.

//

What is garbage collection?
    Garbage is unused and unreferenced objects, and Garbage collection is the process inside JVM which
    identifies and discards those objects which are no longer required in the application.

    ->It is a mechanism of JVM to reclaim heap space from objects which are eligible for garbage collection.

Which objects are eligible for garbage collection?
    Any object on the heap which unreachable through a reference from the stack is eligible for garbage
    collection.

Is programmer responsible to destroy objects?‚≠êÔ∏è
    No! In java programmer need not to worry for this. Garbage collector destroys the objects which are no
    longer in use.
    Before calling garbage collector, it is recommended to make the unused object available for garbage
    collection.

How to make an object available for garbage collection?‚≠êÔ∏è
    There are 4 ways to do so,

    1. Nullifying the reference variable: by doing so the object in heap will be unreachable from the stack.

    2. Reassigning the reference variable: the variable gets assigned with new object and the older one gets
                                          unreferenced from stack..

    3. Object inside method: we know for every method call the stack has a stack frame, which consists of
                            all of its members. When a method is executed the stack frame is popped out from
                            stack and thus all of its members get unreferenced from the stack.

    4. Creating anonymous object: we know an anonymous object is not referenced, so it is eligible for
                                  garbage collection.

How to call garbage collector?
    The most common way to invoke garbage collector is by invoking gc method of system class.
          System.gc();

    Other way is to invoke gc method with Runtime class.
          Runtime.getRuntime().gc();

    This method suggests the JVM to recycle the unused objects in order to make the memory available for
    future allocation.

Can you guarantee that invoking gc will definitely call garbage collector?‚≠êÔ∏è
    By invoking gc, we just request or suggest JVM to call garbage collector. But there is no guarantee
    that the Java virtual machine will do that. So answer is no!

If an object reference is set to null, will the Garbage Collector immediately free the memory held by
that object ?
    No, the object will be available for garbage collection in the next cycle of the garbage collector.

When should we call garbage collector to run?
    When we are executing multiple blocks of code and after executing one block
    -> if we want to free the memory so that the next block of code may execute more efficiently
    -> if you are trying to get more accurate evaluation and want to start those code block with the same
    state as we started the very first block..
    .. then we may call the gc.

Why is it bad idea to run gc?
    As we know we can not guarantee that the garbage collector will process when we call gc, so we should
    just do not bother to do it.
    Because when we call gc, Garbage collection temporarily stops all threads in our application for running.
    When garbage collection takes place our application is temporarily suspended.. and it would not resume
    until the gc process complete.
    This 'stops the world!' That is, running garbage collection can cause an unacceptable freeze in
    execution.

When is the finalize() method gets called? What is the purpose of calling it?
    Finalise method is a special method present in object class. That means every class can override this
    method.
    when we call the gc, it calls the finalise method before performing the clean up activity. This allows
    programmer to perform other clean up activities too
    -> like releasing any system resource, closing connections..

    So when it is called? It is called before performing garbage collection.

    However we can not be assured that the finalise method will be called when we call the gc..
    We don't have any idea that the method is going to be called or not or when this method will going to
    be called.

Why we should not use finalize() method?‚≠êÔ∏è

    There is no assurance that finalize method will get called. Therefore it gets useless sometimes to put
    any clean up code in the finalise method.

So there is no use of finalize method?
    We can use this method to check that are the rosaries are closed or not?
    So you may not use finalize method to correct the problem but at least send out a warning that
    something could be wrong.

What are memory leaks? What are soft references?
    memory leak is a scenario that occurs when objects are no longer being used by the application,
    but the Garbage Collector is unable to remove them from working memory ‚Äì because they‚Äôre still being referenced.
     As a result, the application consumes more and more resources ‚Äì which eventually leads to OutOfMemoryError.

    Soft leaks: it may be possible that any objects are not being used for years but any third party API or
    any other thing is there for keeping it live.. these kind of objects should be garbaged but they are
    not because they are somehow referenced from stack.‚≠êÔ∏è
	
	
	================================================
	
	

1. Have you used Java 8 and Later? What the most important features added in Java 8.

Java 8 is a Major release from Oracle that changes the way of programming and some of the very powerful features added in Java 8 are -

Lambda Expressions & Functional Interface.
Java Stream API
forEach() method in Iterable interface
default and static methods in Interfaces
Java Date and Time API

2. So, What is Lambda Expression ?

And you may answer this Question By Explaining -

In Java Lambda Expressions is the anonymous functions that can be Passed into another method as argument. A function that can be created without belonging to any class. Lambda Expression facilitate passing Behavior or Functions
as parameter to another Functions. This also enables the programming language to be as functional programming language.

3. Now the Next and a bit important Questions That can come in two Ways -

   A) So how do you call / Invoke this Function without name called Lambda?
   B) What is Functional Interface

   The Answer is that, Every Lambda function in Java is Backed up by a Functional Interface. Java Implemented functional programming or
   Lambda Expressions using Interfaces to keep the language's backwards compatibility intact.
   Let me now take you through a full background in The following lecture so that you can understand and answer the Questions around Lambda and
   Functional Interfaces.


4. Can you Convert few Functions into Lambda - and the interviewer may put a function for you to convert that into Lambda.

You may Convert the lambda of functions like this -


Zero parameter:

() -> System.out.println("My without Parameter Lambda");

One parameter:ÔøΩ

(x) -> System.out.println("One parameter: " + x);

Multiple parameters :

(a,b) -> System.out.println("Multiple parameters: " + a + ", " + b);



5. What are Functional interfaces

Functional interfaces, are interfaces having only one abstract method and generally used to invoke Lambda Expression.



6. so what is the difference between anonymous classes and Lambda Expression?

So the main difference between anonymous inner classes and Lambda is

The compiler generates a class file for each anonymous inner class.
For example ÔøΩ AnonymousInnerClass$1.class
Like all classes, it needs to be loaded and verified at startup.

For Lambda compiler uses invoke Dynamic to call the Lambda so no extra class files are generated


7. Can you Name a few Functional Interfaces that are already there in Java 8 to use.

The answer of this question is there are 40+ predefined functional interfaces in Java, Some on the very important functional interfaces to remember are

Consumer  (This consumes the input) having a abstract Method Accept(Object obj)
Predicate (This Functional Interface is used to test some condition) having abstract method test(Object obj)
Supplier  only Supplies does not accept, or return anything back having Method get()
Function  Functional interface is used to apply some operation and return the object back, having method Object apply(Object obj)


8.  What is :: (Double Colun Operator) or Method reference.

   :: Operator of method reference can be used if we want to use an existing method available as Lambda.

   Like in String we want to use toUppercase - Let's see how we can use that

   import java.util.function.Function;

public class Parctice01 {

	public static void main(String[] args) {

		String s="BasicsStrong";
		// There is a method in String toUpperCase and we can refer this using
		// Functional Interface

		Function<String, String> fun = String::toUpperCase;

		String newString=fun.apply("basicsStrong");
		System.out.println(newString);
	}

}


9. Another most important Question the interview may ask is, What is Functional Programming.

In Functional programming Functions are the first class Citizens, Can be passed to another functions and can be returned from another
functions.

Functional Programming mainly supports

Methods Composition (one function returns another)
Passing the Method or behavior Dynamically
Pure Functions
Higher Order Functions

10. What is pure Function?

Pure Functions have below Characteristics.

			 ___________________
			|					|
Input----->	|		f(x)		| -----> OutPut
			|					|
			|___________________|

The return value of the pure funcÔøΩtions solely depends on its arguments Hence, if you call the pure funcÔøΩtions with the same set of arguÔøΩments, you will always get the same return values.

They do not have any side effects like netÔøΩwork or dataÔøΩbase calls

They do not modÔøΩify the arguÔøΩments which are passed to them

With this pure functions comes with a Great Benefit and can be used fearlessly in Multithreaded programs as they will never Modify the
shared State or variables.

Example :

public static int sum(int a, int b) {
    return a + b;
}

This function, satisfies all the requirements of being pure.



At the same time ...

public static int sum(int a, int b) {
    return new Math.Random().nextInt() + a + b;
} // This is Impure becasue it Voilates the first Rule.


public static int sum(int a, int b) {
    writeSomethingToFile();
    return a + b;
}  // This is also impure because it voilates the second rule.


11. What are Higher Order Functions? or Functional Composition?

The Functions that return another Function is called Higher Order Functions, and applying these functions one by one like Fluid Operations are called Functional Composition

Let's understand this with an Example -

Look at this code closely this is returning a Function, so this can be called as Higher Order Function.

public static Comparator<String> reverse(Comparator<String> comp) {
    return (x, y) -> comp.compare(y, x);
}


12. What is Stream in Java.

A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result. Stream connects to
the data source and convert that into a flow of Objects, that can be processed using methods one by one.
Let's take an Example -

public class Parctice02 {

	public static void main(String[] args) {

		List<Integer> list=Arrays.asList(1,2,2,3,4,5,6,7,8,9);

		List is converted into Stream Here where the Elements will flow one by on and processed as per the operations applied.
		List evenList=list.stream()
			.filter(e -> e%2==0)
			.collect(Collectors.toList());

		System.out.println(evenList);

		// In this Example list of Integers has been converted into Stream
		// then Filter Method is applied and lambda is passed to filter only even items
		// then finally collect operation is called to collect the Items to another list
	}


}

13. What do you mean by Pipeline of Operations?

To perform a sequence of operations over the elements of the data source and process and get the results,

There are three things Required

Data source
Intermediate operation(s)
Terminal operation.

Data Source is the Dataset or collection to which the Stream will be created.

There are various operations in Stream that is Intermediate -

filter()
map()
flatMap()
distinct()
sorted()
peek()
limit()
skip()

Intermediate operations are lazy and will not be called until the Terminal operation is called. To identify if the operation is Intermediate
or not we can check

If the operation is returning another stream it is called intermediate operation.

The terminal operation is the final operations that will be called after triggering the Intermediate operations.

Some of the Example of Terminal operations are.

toArray()
collect()
count()
reduce()
forEach()
forEachOrdered()
min()
max()
anyMatch()
allMatch()
noneMatch()
findAny()
findFirst()

In the Example above - filter is a intermediate operation and collect is the terminal operation

List<Integer> list=Arrays.asList(1,2,2,3,4,5,6,7,8,9);

		List is converted into Stream Here where the Elements will flow one by on and processed as per the operations applied.
		List evenList=list.stream()
			.filter(e -> e%2==0)
			.collect(Collectors.toList());

		System.out.println(evenList);

14. What do you mean by Lazy evaluation?


Lazy evaluation is that Intermediate operations are not executed, until required, and JVM intelligently calls intermediate operations.

Let's prove this using an Example

package com.basicsstrong.apidesign;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Parctice02 {

	public static void main(String[] args) {


		List<Person> persons = new ArrayList<>();
		persons.add(new Person("John",36));
		persons.add(new Person("Erick",39));
		persons.add(new Person("Mickel",56));
		persons.add(new Person("Bob",33));

		// This is just a Intermediate Operation Let see if the get Method gets executed by
		// Putting a Debug code there

		Stream<Person> stream = persons.stream()
			   .filter(e -> e.getAge() <= 36);

		// Nothing Happenes.

		// Let's now add one terminal operation


		List<Person> newlist = persons.stream()
				   .filter(e -> e.getAge() <= 36)
				   .collect(Collectors.toList());
		// See the getMethod call takes place and Stream is filtered

		System.out.println(newlist);
	}

}

class Person{

	String name;
	int age;

	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {

		System.out.println("I am in getAge Mthod of Persons");

		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}


}

15. What are parallel Streams :

Parallel Streams can take advantage of MultiCore processors, and get executed in parallel. But you should take care while using parallel streams



16. Why default methods got introduced in Java 8

For Making, Functional interfaces more Functional to support Composition and Higher Order functions. Functional interfaces needed to have Methods inside.
But Java Could not do that because of backward compatibility. If they could have add a method in existing interface all the application using
those interfaces had to implement That.

That's why Java introduced Default Methods. Others can override if they need their implementation else, default implementation would remain there.

================================================

//Identifiers

L1-00:35 What are identifiers in java?
    Name used to identify the class or a variable or A label or a method or a package.. such things
    is called an identifier

      package com.basicsstrong.fundamentals;
      class Demo{
      	int a;
      	public void display(){}

      }

    Here
    Package name 'com.basicsstrong.fundamentals',
    Class name 'Demo',
    Variable name 'a',
    Method name 'display()' are identifiers.

    -> Identifiers are case-sensitive, and we can define identifiers of any length. (preferred 4-15)

L1-01:44 In below example, how many identifiers are there?
public class Demo{
	public static void main(String[] args){
		int a = 20;
	}
}
      There are 5 identifiers.
      1. ClassName 'Demo',
      2. MethodName 'main',
      3. Predefined ClassName 'String',
      4. Variable name 'args',
      5. Variable name 'a'.

L1-02:53 which characters are allowed for identifiers?
    Identifiers can have all the-
    -> alphanumeric characters [A-Z],[a-z],[0-9],
    -> '$' dollar sign and the underscore '_'

L1-03:22 Can we have an identifier starting with a digit?
    Answer is No, any identifier starting with digit is not a valid java identifier.
    -> We cannot have '1stVariable' as identifier.

L1-03:49 Can we use reserved word as identifier? ‚≠êÔ∏è
    No, we can not use reserved words as identifiers. for example,
        String final = "final string";      //invalid statement

//Reserved Words

L2-00:07 What are reserved words? ‚≠êÔ∏è
    Any programming language reserves some words to represent some functionalities defined by that
    particular language, such words are called reserved words.
    It consists of Keywords and literals.

L2-00:35 How many keywords are there in java?
    For defining some functionalities, There are around 50 keywords in java,
    which includes data types, modifiers, keywords related to flow control, and many more.

L2-03:34 What are unused keywords? ‚≠êÔ∏è
    Goto and const are the keywords which are reserved by java but have not used until now.

L2-04:21 Can we use predefined Class name as identifier?
    Answer is Yes, we can use predefined Class name as identifier.
	     String String = "Basics";

    But it is not recommended to, because it reduces the readability and creates complexity in code.

L2-04:56 Explain var keyword in java?
    'var' is a keyword which is added in java 10, which allows us to declare a variable without defining
    their type.

      String str = "my string";   ->    var str = "my String"; var i = 10;

L2-05:41 Is null a keyword?
    No, null is not a keyword. It is a literal.

L2-05:50 What are literals? ‚≠êÔ∏è
    Literals are the constant values which can be assigned to the variable.
    For example,

    String s = "BasicsStrong";
      -> BasicsStrong is a literal.

    And java provides 3 literals, which are null, true, false.

    1. Integral Literals for byte, short, int, long.
    2. Floating-Point Literals for float and double.
    3. Char Literals for char.
    4. String Literals for strings.
    5. Boolean Literals which are true and false.

//Data types

L3-00:05 What are various primitive data type in java?‚≠êÔ∏è
    There are 8 primitive data types:
    1. byte
	       The byte data type is an 8-bit signed Two-s complement integer.
         Size : 8 bit
         Value : -128 to 127.

    2. short
	       The short data type is 16-bit signed two-s complement integer.
         Size : 16 bit
         Value : -32768 to 32767.

	  üëâüèª Both byte and short are useful for saving memory in large arrays.

    3. int      [int i = 100;]
	       It is a 32-bit signed two-s compliment integer.
         Size : 32 bit
         Value : -2^31 to (2^31)-1

    üëâüèª int data type is generally used for numeric values.

    üëâüèª In java SE8 and later, we can also use int data type as unsigned 32-bit integer which has value
    in range [0,2^31 - 1]. and for that we use Integer class.

    4. long
	       Long data type is 64-bit two-s compliment integer.
         Size : 64 bit.
         Value : -2^63 to 2^63 -1.

    üëâüèª The Long Class can be used to represent an unsigned 64-bit long.

    5. float
	       Float data type is a 32-bit floating point. And to define a float data type
         we use f or F suffix.
	        like this,
	         float f = 10.7f;

    6. double
	       double is a 64-bit floating point. It is the default data type for decimal values.
	        double d = 7.34456

    üëâüèª Float and double are used for scientific calculations.

    7. boolean
	       boolean data type represents only one bit of information, it can be either true or false.

    8. char
	       The char data type is a single 16-bit Unicode character. Note that it is a single character.
            char c = 'B';

L3-03:14 What is difference between double and float variables?
    -> Float takes 4 bytes in memory whereas double takes 8 bytes in memory.
    So float is single precision floating point and double is double precision decimal number..

    -> If we want to save memory in large arrays of floating point numbers, then we should use a
    float instead of double.

L3-03:49 What is implicit conversion in java?‚≠êÔ∏è
    Type conversion in java is converting a type into another type.
      Two type of type casting in java,
      -> Implicit
      -> Explicit

    Implicit type conversion wides the range of any type.
      In this, one primitive is converted into another one.
      It is automatic type conversion which happens only when both type are compatible and target
      type is larger than source type. for example,

      int a = 50;
      long b = a;

      Here int a will be converted into long type without any explicit casting.

L3-07:14 How to make any variable constant so that it cannot get changed through out the program?
    We can declare any variable final, with final keyword.
    -> a final value can never be changed.

    final double a = 2.4;

L3-08:06 What are the default values for all primitive types?
    For boolean -> false
    For byte -> 0
    short -> 0
    int -> 0
    long -> 0l
    char -> /u0000
    float -> 0.0f
    double -> 0.0d
    And when it comes to any object, the default value is -> null

L3-08:37 What are the Wrapper classes available for primitive types?
    Wrapper classes are the wrappers to primitive data types.
    üëâüèª By using wrapper classes we are allowed to access primitives as objects.
      For every primitive type there is a Wrapper Class present in java:
          boolean  - java.lang.Boolean
          byte - java.lang.Byte
          char - java.lang.Character
          double - java.lang.Double
          float - java.lang.Float
          int - java.lang.Integer
          long - java.lang.Long
          short - java.lang.Short
          void - java.lang.Void

L3-09:26 How primitive variable passed to methods? By value or by reference?‚≠êÔ∏è
    In java, primitives are passed to methods by value.
    So that, when the passed value changes in the method, it does not change the original value.

L3-00:00 Is it correct to say that Classes and interfaces are data types or data structure?
    We can consider a Class as Data type but interfaces can not be seen as data types because they
    do not hold anything.

//Main method

L4-00:13 What is main method?
    main method is a method which is entry point of execution of any java program.

    public class Exercise{
    	public static void main(String[] args){
    		int a = 10;
    		byte b = 2;
    		char c = 'A';
    		double d = 2.4;
    		//lets add these values,
    		System.out.println(a+b+c+d);

    	}
    }

    So main method is an standard method which is used by JVM to start executing the program.

L4-00:58 What is String args[] in main method?
    Main method has an argument, 'args array' of type string.
    However we can name it anything in place of args but mostly programmers prefer to name it args.

    -> When we run the program from command prompt we can pass some input to our java program.
    That input will get stored in String args array.

    -> We can also specify String argument for main method using run configuration in eclipse.

L4-02:51 Why the main method is public static?
    -> Any method of any Class can be accessed only by creating its instance unless it is static method.

    üëâüèª Java uses the main() method as the entry point of execution, so if main() method is
    declared non-static then JVM would not be able to call it without creating the instance of that Class.

    JVM cannot create instance of the main Class as there is no standard constructor defined in
    main class.

    üëâüèª Main method is public so that it is visible to every class. If its not public,
    then JVM classes might not be able to access it.

    These are the reasons why main method is public and static.
    And as it does not return anything so it is void.‚≠êÔ∏è

L4-04:33 Can we run any java program without main method?
    We can not. Before JDK7 we had static initialisers as an alternative approach for main method but
    from JDK 7 we cannot do so.

          //static initialiser:
          public class Demo{
          	static{
          		sysout();
          		System.exit(0);
          	}
          }

    It is mandatory to write main method because it is the entry point of java application in case of
    core Java.
    In case of other container managed environment like Servlet, EJB etc, java programs have their
    own life-cycles. so we do not need to write main method in such environments.

L4-05:36 Can we change signature of main method?‚≠êÔ∏è
    No, we can not change anything while defining the standard main method in java.
    We cannot define it non-static, private - protected, or we can not change its return type which is
    void.

    If we change anything then JVM will consider that method as any other ordinary method, and will
    continue to search for the standard main method.
    If it does not find that, the runtime error will occur.

L5-07:10 Can we make main method final in java?‚≠êÔ∏è
    Answer is yes, we can declare main method as final.
    This makes its implementation final; any other Class would not be able to change it.
	
	===============================================
	
	
L1-00:19 What is MultiThreading and its Purpose?
  Its a way to achieve multi-tasking in java.

  Multi-tasking is acheived in 2 ways:
  1. Process Based
  2. Thread Based is Multi-MultiThreading

 What is Thread? ‚≠êÔ∏è
  Thread is separate path of execution in program.
  Threads are, Light weight,They share the same address space. creating thread is simple
  when compared to process because creating thread requires less resources when compared to
  process.

How to create a Thread? How to acheive Multi-Threading programmatically using Threads?
  1. By extending Thread Class
  2. By implementing Runnable Interface

Which approach is better? ‚≠êÔ∏è
  implementing Runnable is a better approach.

What is Main Thread?
  Thread responsible to execute the main method.

why we call start method? can't we directly call run method? ‚≠êÔ∏è
  If we directly call run method..
  then we are calling a normal method without creating a new thread.
  that is run method will behave as normal method and now child thread will not get started
  and there will only be main thread that will execute this run method.

  Start Method:
  Registering the thread with Thread Scheduler
  Perform all the mandatory activities
  invoke run

Can we overload the run method?
  yes ,but that start method written in Thread class invokes the no argument run method.
  so if you overload the run method,
  the run method that will get invoked by the start method will
  only be the one with no arguments.

Can we override the start method?
  It will not execute the necessary steps that thread class start method is having.
  Thats why you should not override the start method.
  still if you want to override the start method,
  you can first call the super of Thread class using super.start() and then can give additional implementation.

What is Thread Scheduler?
  It is a part of JVM.
  It is responsible for the order in which the threads get executed
  and there is no assurity of the algorithm used by the scheduler to order
  the threads. It varies from JVM to JVM

Explain the life-cycle of a Thread?
    A thread can be in any of the five states :
    New : When the instance of thread is created it will be in New state.
    Ex : Thread t= new Thread();
    In the above example t is in new state.
    The thread is created but not in active state to make it active,
    we need to call start() method on it.


    Runnable state : A thread can be in the runnable state in either of the following
     two ways :
     When the start method is invoked or
     A thread can also be in runnable state after coming back from blocked or sleeping
     or waiting state.

    Running state : If thread scheduler allocates cpu time, then the thread will be
    in running state.

    Blocking/ Waiting / sleeping states : In this state the thread can be made temprorily
    inactive for a short period of time
    the above state in any of the following ways:
    1) The thread waits to acquire lock of an object.
    2) The thread waits for another thread to complete.
    3) The thread waits for notification of other thread.

    Dead State : A thread is in dead state when thread‚Äôs run method execution
    is complete. It dies automatically when thread‚Äô's run method execution is completed
    and the thread object will be garbage collected.

//sleep(), yield(), join(), Thread name, Thread Groups, Thread Priorities....

What are thread priorities and importance of thread priorities in java?
  Thread priorities determine which thread to run. Every thread has a priority.
  A thread inherits priority of its parent thread.
  By default thread has normal priority of 5.
  Thread scheduler uses thread priorities to decide when each thread is allowed to run.
  Thread scheduler runs higher priority threads first.

Explain different types of thread priorities ?
    Every thread in java has priority in between 1 to 10.
    By default priority is 5 (Thread.NORM_PRIORITY).
    The maximum priority would be 10 and minimum is 1.
    Thread class defines the following constants(static final variables) to define properties.
    Thread. MIN_PRIORITY = 1;
    Thread.NORM_PRIORITY=5;
    Thread. MAX_PRIORITY=10;

How to change the priority of thread or how to set priority of thread?
    Thread class has a set method to set the priority of thread
    Signature : final void setPriority(int value);
    The setPriority() method is a request to JVM to set the priority. JVM may or may not oblige the request.
    We can get the priority of current thread by using getPriority() method of Thread class.
    final int getPriority() {
    }

If two threads have same priority which thread will be executed first ?
    We are not guaranteed which thread will be executed first when there are threads with equal priorities.
    It depends on thread scheduler that which thread to execute.

What all methods are used to prevent thread execution ?
    There are three methods in Thread class which prevents execution of thread.
    1) yield()
    2) join()
    3) sleep()

Explain yield() method in thread class ?
    Yield() method makes the current running thread to move in to runnable state from running state
    giving chance to remaining threads of equal priority which are in waiting state.
    yield() makes current thread to sleep for a specified amount of time.T
    here is no guarantee that moving a current running thread from runnable to running state.
    It all depends on thread scheduler it doesn‚Äôt guarantee anything.

Explain how join method works?
    A thread can invoke the join() method on other thread to wait for other thread to complete its
    execution. Assume we have two threads, t1 and t2 threads .
    A running thread t1 invokes join() on thread t2 then t1 thread will wait in to waiting state until t2 completes.
    Once t2 completes the execution, t1 will continue.
    join() method throws Interrupted Exception so when ever we use join() method
    we should handle Interrrupted Exception by throws or by using try catch block.

Explain purpose of sleep() method in java?
    sleep() method causes current running thread to sleep for specified amount of time .
    Now lets see the syntaX:
    first one: public static native void sleep(long ms). //its a native one not written in java
    second one: public static void sleep(long ms,int ns).

    there is no sleep method with no argument..with sleep there must be the interval for which we want to
    make the thread sleep.

Explain about interrupt() method of thread class ?
    If any thread is in sleeping or waiting state (i.e. sleep() or wait() is invoked),
    calling the interrupt() method on the thread, breaks out the sleeping or waiting state
    throwing InterruptedException. This is reason we need to handle interrupted exception with throws
    or try/ catch block.

What is Race Condition and when it occur?‚≠êÔ∏è
    when more than one thread operate on same object without proper synchronization
    then the thread operations interleaves on each other.
    that is, one thread is modifying the object data and in some intermediate state where
    the updation is not yet completed some other thread performs modification on
    the intermediate data resulting to data inconsistency.
    and this condition is called race condition.
    this happens when the operations that the threads are performing
    are non-atomic and this is why thread operation interleaves on each other.

What are atomic and non atomic operations? Can volatile make a non-atomic operation to atomic?
    Atomic operations take place in one step.
    where as non-atomic operations takes place in multiple steps internally.
    java provides volatile keyword to make assignment or read or write operations atomic.
  	we can use volatile before long and double and boolean to avoid data inconsistency.
  	but you can't do anything compound such as incrementing it safely, because that's a read/modify/
  	write cycle.

What is Synchronization?
	we can guard the critical section to avoid data inconsistency so that only one thread have access or execute
  this section of the code at a time.
	that is only one thread enters this section at at a time
  and when it exits other thread can enter this section.

what is critical section?
	A critical section in java multithreading is a piece of code that access shared resources.
	that is why there are chances of data inconsistency or race condition if multiple threads operate simultaneously.

What are the ways to acheive synchronization?
  Two ways:
  1.Synchronized methods
  2.Synchronized blocks

When a thread is executing synchronized methods ,
then is it possible to execute other synchronized methods simultaneously by other threads on the same object?
      No it is not possible to execute synchronized methods by other threads on the same object
      when a thread is inside a synchronized method.

      example:

      Student s = new Student();

      class Student{
        synchronized public void method1(){    //can only be executed on s by the thread having the lock of s

        }

        synchronized public void method2(){   //can only be executed on s by the thread having the lock of s

        }

        public void method3(){                //any thread can execute this method on s.

        }
      }

When a thread is executing synchronized methods ,
then is it possible to execute other synchronized methods simultaneously by other threads on different objects?
	 yes, its is possible. Other threads are only restricted to execute the synchronized methods on the
   object whose lock is already aquired by the thread.

Can we synchronize static methods in java?
    Every class in java has a unique lock associated with it.
    If a thread wants to execute static synchronize method it need to acquire class level lock.
    When a thread was executing static synchronized method no other thread can execute
    static synchronized method of class since lock is acquired on class.
    But it can execute the following methods simultaneously :
    1) Normal static methods
    2) Normal instance methods
    3) Synchronized instance methods

    class Student{

      synchronized public static void staticMethod1(){  //can only be executed by the thread having the lock of class Student

      }

      public static void staticMethod2(){  //can be executed by any thread

      }


      synchronized public void method1(){    //can only be executed by any thread

      }

      synchronized public void method2(){   //can only be executed by any thread

      }

      public void method3(){               //can only be executed by any thread

      }
    }

Can we use synchronized block for primitives?

    Student s = new Student();

    synchronized (s){

    }

    class Student{

           public static void staticMethod1(){
              //can only be executed by the thread having the lock of class Student

              synchronized(Student.class){

              }

          }

          public static void staticMethod2(){  //can be executed by any thread

          }


           public void method1(){
                 //can only be executed by any thread

                 synchronized (this){

                 }

          }

          synchronized public void method2(){   //can only be executed by any thread

          }

          public void method3(){               //can only be executed by any thread

          }
        }

      Synchronized blocks are applicable only for objects. If we try to use
      synchronized blocks for primitives we get compile time error.

Why we use explicit lock?
    It provides additional features

//Inter-Thread communication

Explain about inter-thread communication and how it takes place in java?
    Usually threads are created to perform different unrelated tasks but
    there may be situations where they may perform related tasks or they need to communicate to other threads.
    one of the example of this is Producer Consumer problem. Inter-thread communication
    in java is done with the help of following three methods :
    1) wait()
    2) notify()
    3) notifyAll()

Explain wait(), notify() and notifyAll() methods of object class ?
  	wait() : wait() method releases the lock on object until some other thread acquires the lock and calls notify().
  	notify() :notify() method wakes up the thread that called wait on the same object.
  	notfiyAll() :notifyAll() method wakes up all the threads that called wait() on the same object.
    The highest priority threads will run first.
  	All the above three methods are in object class and are called only in synchronized context.
  	All the above three methods must handle InterruptedException by using throws clause or by using try
    catch clause.

Write code to solve the Produce consumer problem in Java? ‚≠êÔ∏è

when wait(), notify(), notifyAll() methods are called does it releases the lock or holds the acquired lock?
  	when the thread enter in synchronized context thread acquires the lock on current object. When
  	wait(), notify(), notifyAll() methods are called lock is released on that object.

Explain why wait(), notify() and notifyAll() methods are in Object class rather than in thread class?
  	wait() , notify(), notifyAll() methods are object level methods they are called on same object.
  	these methods are called on an shared object so they are kept in object class rather than thread
  	class.

Explain IllegalMonitorStateException and when it will be thrown?
  	IllegalMonitorStateException is thrown when wait(), notify() and notifyAll() are called in non
  	synchronized context. Wait(), notify(),notifyAll() must always be called in synchronized context
  	other wise we get this run time exception.
  	whenever we call these methods lock is acquired or released on that object so they must be called
    from within synchronized area.

//other

Explain which of the following methods releases the lock when invoked?
  	yield()    No
  	join()     No
  	sleep()    No
  	wait()     Yes
  	notify()   Yes
  	notifyAll()  Yes


Can we restart a dead thread in java?
  	 If we try to restart a dead thread by using start method, we will get run time exception since the
     thread is not alive.

Can one thread block the other thread?
  	No, one thread cannot block the other thread in java. It can block the current thread that is running.
  	for example if we yield a thread..it blocks itself to give chance to other thread..but we can't
    block other thread.

Can we restart a thread already started in java?
    We start a thread using start() method in java.
    If we call start method second time once it is started it will cause RunTimeException(IllegalThreadStateException).
    A runnable thread cannot be restarted.


//liveness problems, Daemon Threads, Immutable Objects (Thread Safety)

What is liveness? What are liveness problems?
  	A concurrent application's ability to execute in a timely manner is known as its liveness.
  	Liveness problems include:
  	Deadlock,
  	Starvation,
  	Livelock

What is deadlock? ‚≠êÔ∏è
  	When two or more threads are waiting for each other to release the resource or lock
  	and get stuck for infinite time, the situation is called deadlock.

Write a program which will result in a deadlock? How will you fix deadlock in Java?‚≠êÔ∏è

How many types of threads are there in Java?
    Java offers two types of threads:
    1.user threads
    2.daemon threads.

What are daemon threads in java?‚≠êÔ∏è
    Daemon threads are threads which run in background.
    Daemon thread is mostly created by JVM.
    For example: Garbage collector
    These are service threads and works for the benefit of other threads.
    If parent thread is daemon, child thread also inherits daemon nature of thread.
    JVM will force daemon thread to terminate if all user threads have finished their execution
    but The user thread is closed by itself.

How to make a non daemon thread as daemon?
    By default all threads are non daemon.
    We can make non daemon thread daemon using setDaemon() method.
    we call setDaemon() only before start() method.
    If we call setDaemon() after start() method an IllegalThreadStateException will be thrown.

Can we make main() thread as daemon?
    Main thread is always non daemon.
    We cannot make it daemon.

How immutability simplify the concurrency?
  	Immutable objects are by default thread-safe because there state can not be modified once created.
  	So we do not have to take care of data inconsistency in case of immutable objects.
  	For example: All the Wrapper classes (Integer, Long, Byte, Double, Float, Short),String class

//Advanced Multithreading

What is Thread Group? Why it‚Äôs advised not to use it?
    Thread group is a collection of threads or sub thread groups
    that are responsible for doing something similar and Java provides a convenient way to group multiple
    threads in a single object .The advantage of using thread group is that we can perform common operation on the whole
    group so in other words programmer can group the threads in thread group based on their functions to
    be performed.
    But ThreadGroup API is weak and it doesn‚Äôt have any functionality that is not provided by Thread.
    Two of the major feature it had are to get the list of active threads in a thread group
    and to set the uncaught exception handler for the thread.
    So ThreadGroup is obsolete and hence not advised to use anymore.

What is Thread Pool? How can we create Thread Pool in Java?
    A thread pool manages the pool of threads, it contains a queue that keeps tasks waiting to get executed.
    java.util.concurrent.Executors provide implementation of java.util.concurrent.
    Executor interface to create the thread pool in java.

What is Callable?‚≠êÔ∏è
    Callable is an interface with single abstract method call().
    Java 5 introduced java.util.concurrent.Callable interface in concurrency package
    that is similar to Runnable interface but it can return any Object and is able to throw Exception.
    Callable interface use Generic to define the return type of Object.

What is ExecutorService?‚≠êÔ∏è
    The Java ExecutorService is a construct that allows you to pass a task to be executed by a thread asynchronously.
    The executor service creates and maintains a reusable pool of threads for executing submitted tasks.

How to create executor service?
    ExecutorService executorService =
        new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>());

    ExecutorService executor = Executors.newFixedThreadPool(10);

    ExecutorService executor = Executors.newSingleThreadExecutor();

    ExecutorService executor = Executors.newCachedThreadPool();

    ExecutorService executor = Executors.newScheduledThreadPool(5);

    ExecutorService executor = Executors.newSingleThreadScheduledExecutor();

    ExecutorService executor = Executors.newWorkStealingPool();

How do you execute a callable from executorservice?
    We pass the callable task inside the submit method
    and invoke the submit on the created ExecutorService.

How do you execute runnable task from executorservice?
    We pass the runnable in the execute method and invoke it on the ExecutorService.

What is Future?‚≠êÔ∏è
    Executors class provide useful methods to execute Callable in a thread pool.
    Since callable tasks run in parallel, we have to wait for the returned Object.
    Callable tasks return java.util.concurrent.Future object.
    Using Future we can find out the status of the Callable task and get the returned Object.
    It provides get() method that can wait for the Callable to finish and then return the result.
    So, Future is basically a placeholder for the object which is going to be
    returned by the callable task at any time in future.

What is ThreadLocal?
    Java ThreadLocal is used to create thread-local variables. i.e., variables local to each thread.
    We know that all threads on an Object share it‚Äôs variables, so if the variable is not thread safe,
    we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables.
    If the same code runs in different threads, these executions will not share the value, instead of that, each
    thread has its own variable that is local to the thread and they can use it‚Äôs get() and set() methods
    to get the default value or change it‚Äôs value local to Thread.
    ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread.

What is Java Thread Dump, How can we get Java Thread dump of a Program?
    Thread dump is list of all the threads active in the JVM,
    thread dumps are very helpful in analyzing bottlenecks in the application
    and analyzing deadlock situations.
    There are many ways using which we can generate Thread dump ‚Äì
    Using Profiler, Kill -3 command, jstack tool etc.

How to schedule a task to run after specific interval?
    java.util.TimerTask is an abstract class that implements Runnable interface
    and we need to extend this class to create our own TimerTask that can be scheduled using java Timer class and
    java.util.Timer class can be used to schedule a task to
    be run one-time or to be run at regular intervals at certain time in future.

What is context switching in multithreading ?
    Context Switching is the process of storing and restoring of CPU state
    so that Thread execution can be resumed from the same point at a later point of time.
    Context Switching is the essential feature for multitasking operating system and
    support for multi-threaded environment.

What is fork join pool?‚≠êÔ∏è
  fork join

What is completable future?
  completable Future

What is FutureTask Class?
    FutureTask is the base implementation class of Future interface
    and we can use it with Executors for asynchronous processing.
    Most of the time we don‚Äôt need to use FutureTask class but it comes real handy
    if we want to override some of the methods of Future interface and want to keep most of the base implementation.
    We can just extend this class and override the methods according to our requirements.


//Concurrent Collection And Concurrent Utilities

What are Concurrent Collection Classes?
    Java Collection classes are fail-fast which means that if the Collection is changed while
    some thread is traversing over it using iterator, the iterator.next() will throw ConcurrentModificationException.
    Concurrent Collection classes support full concurrency of retrievals and
    adjustable expected concurrency for updates.
    Major classes are ConcurrentHashMap, CopyOnWriteArrayList and CopyOnWriteArraySet, LinkedBlockingQueue etc.

Briefly explain concurrentHashMap. How is it better than HashMap and HashTable in terms of concurrency?

Briefly explain CopyOnwriteArraylist. Can we perform remove operation on CopyOnwriteArraylist while iterating?

explain CopyOnwriteArraySet.

What is CountDownLatch? When we use CountDownLatch?

What is CyclicBarrier? What is the difference between CountDownLatch and CyclicBarrier?

What is BlockingQueue? How can we implement Producer-Consumer problem using Blocking Queue?

What is Exchanger? How do exchanger work?

Briefly explain Semaphore.

List the implementations of BlockingQueue.
    ArrayBlockingQueue,
    DelayQueue,
    LinkedBlockingQueue,
    PriorityBlockingQueue,
    and SynchronousQueue.
	
	
	============================================================
	
	
	
//Object Oriented Programming [OOP]

//Classes and Objects - Building Blocks of OOP

L1-00:45 What are classes and objects?
		A Class is a user-defined-blueprint from which objects are created, which has attributes and behavior.

L1-04:30 How can we create class?
		We can define a Class in java, using keyword "class".

			class <ClassName>
			{
				//Variables
				//Methods...
			}

		For example:

			class Fan{
				private boolean isOn;

				public void turnOn(){
				isOn = true;
				}

				public void turnOff(){
				isOn = false;
				}
			}

 		Class members: isOn [Data member], turnOn() turnOff() [Member functions]

L1-09:07 How to create objects?
		We create objects with the keyword 'new'.

			<classname> ref = new <classname>();

L1-13:41 How many classes we can create in a java file?
		We can create any number of classes in a java file.
		üëâüèª We can have only one Public Class in a java file.


//modifiers

L2-00:22 There are two types of modifiers present in java
    		1. Access modifiers
    		2. Non-Access Modifiers.

L2-00:29 What are the Access modifiers in java?
    		Access Modifiers are the keywords in object oriented language, which set the accessibility of classes
    		or methods or any members.

    		-> Using public modifier we specify that the Class can be accessed everywhere.

L2-01:13 How many access modifiers are there in java?
    		1. public
    		2. private
    		3. protected
    		4. <default>

    	public:
    			 public members can be accessed anywhere, in any class, present in any Package.

    	default:
    			 When there is no modifier used, then the component has default accessibilities.
    			 -> Classes with no modifier said to be default classes. The scope for the default classes
    		   and default Class members is within their Package.

    	private:
    			 Private members cannot be accessed anywhere except in the Class itself where they are declared.

    	protected:
    			 Protected members can be accessed within the same Package and in its subclass,
    			 but it cannot be accessed in the other packages excepts its child classes.

    			 So their scope is limited to its Package and its subclasses.

L3-00:02 What is a Package?
    		A Package is a mechanism to keep all classes, interfaces and sub-packages;
    		which has similar functionalities, at the same place.

    		Packages provides a folder structure to organize our classes-interfaces, so that one can easily
    		search and use them.

L3-01:12 How can we access a Class outside its Package?
    		To use a Class outside its Package we must Import it, using the 'import' keyword.
    		For example,

    		import com.basicsstrong.oops.<theclassname>;

L3-01:55 Can we declare a Top level Class private?
    		Answer is no, A Class can be public or default.

    		Inner class: Class defined in a class.

    		Inner classes can be declared as private or protected as they are the members of the class.
    		-> Top level Class can not be private or protected.

L3-03:10 Which access modifier is the least restrictive and which is the most restrictive?
    		Least Restrictive Modifier: Public access modifier
    				-> It is also known as Universal Access Modifier.

    		Most Restrictive access modifier : private.

L4-00:04 What are non-access modifiers in java?
    		1. Static :
    						static keyword is used to specify whether the member is a Class member or an instance member.
    						If a member is defined static, then it is said to be Class member.

    		2. Final :
    						final specifier is used to restrict further modifications on any class, any method or any
    						variable.
    						-> if any primitive variable is final, we cannot change its value in whole program.

    		3. Abstract :
    						abstract specifier is used to mark the method or Class to be incomplete and to must be
    						modified further by other classes.

    		4. Synchronized :
    						This is used to achieve thread safety in multithreaded environment which is about executing
    						tasks simultaneously with different threads.

L4-06:35 Can a Class or a method be abstract and final at the same time?
    		A Class or a method cannot be abstract or final at the same time.
    		-> Final restricts the component to be modified further.
    		-> abstract make component available to be modified further.

L4-06:56 What do you mean by abstract classes?
    		A Class with abstract specifier is a abstract class.

    		If a Class is abstract it is not fully implemented and if a method is abstract, it does not have
    		any implementation.

    		üëâüèª abstract methods can only be defined in abstract class.

L4-07:32 what is abstract method?
    		A method without any implementation or definition is an Abstract method.
    		Abstract method are declared with the keyword abstract.

L4-09:33 Can we define an abstract method in a non-abstract class?
    		We can not declare any abstract method in a non-abstract class.

L4-09:50 Can an abstract method be declared as private?
    		No, abstract method cannot be declared as private, as they are meant to be used in other classes,
    		so they must be public, or default or protected.

L4-10:48 Can we instantiate abstract classes?
    		Answer is No, since abstract classes are not fully implemented that is why we cannot create objects
    		of them.

L4-11:29 Can we define top level Class as static?
    		Answer is No. static keyword is applicable only for Class members.

L4-12:09 Why do we define members as static?
    		Static keyword is used to define the members independent from any instance.
    		Static members exist independently of any instances created for the class.

    		-> Defining a method static will make it independent of any instance.
    		We can call static members without creating objects, by just invoking them with the classname..


//variables, Methods, Constructors

L6-00:11 What is a variable? What are the types of variable in java?
    		Variable is a name which is given to a memory shell. It is a container that used to store data values.
    		Variable can store primitives or objects.

    		Class can have these variables:

    		Instance Variable [defined inside class, outside the method]
    		Local Variable 		[defined inside a method or block or constructor]
    		Class Variables		[defined in Class and outside any method but with static keyword]

    		//What is the difference between Instance variables , Local variables and Static variables?

L6-04:33 When are static variables loaded in memory?
    		Static variables are loaded in memory at the time of Class loading. i.e,
    		When we load the class, the static members are the first to load.

L6-04:53 Are there any global variables in java?
    		Global variables are generally those variable which can be accessed by other part of program or
    		outside the class.

    		Java does not allow to have global variables. As it does not fit good with the oops.

L6-05:32 Can we declare final variable without initialization?
    		Yes, we can declare final variable without initialisation.
    		-> Such variables are called as Blank Final Variable.
    			 Blank final variable can be static or non-static..

    		This is how we declare blank final variables:

    				private static final int blank_final;

    		We have to initialize  blank final varables before any usage.

    		static blank final variables can be initialised in static block..

L6-08:45 Can we make the local variable final?
    		Yes, we can define a local variable as final.
    		üëâüèª It is the only modifier which is acceptable to a local variable.

L6-09:08 What is Constructor?
    		Constructor is a special kind of method which is used to initialise objects.
    		The name of constructor is same as of its class.

    				class Fan{
    				    Fan(){
    				      //this is constructor.
    				    }
    				}

L6-09:38 What are the various types of constructors?
    		There are three types of constructors..
    		1. default Constructor: if we do not write constructor in program, then this constructor is called automatically.
    		2. Non-Parameterised Constructor : the constructor with no-arguments
    		3. Parameterised Constructor : the constructor with arguments is called as parameterised.

L6:10:56 When constructors are called?
    		Constructor are called at the time we create objects using 'new' keyword.

    		üëâüèª If we have not written any constructor in program then it takes default constructor automatically
    		and initialise the data members with their default values.

L6-16:06 Can a constructor be final or static or abstract?
    		No, Constructor cannot have any Non-access modifiers.

    		-> The constructor can not be final because once we create anything final, then that method cannot
    		be modified by other class, and as the Constructor already can not be overridden or modified by any
    		class, there is no need of final keyword.

    		-> abstract method does not have body. They have only declaration.
    		But constructor cannot lack a body, thats why constructor can not be abstract.

    		-> static members always belong to class, not to any objects. Therefore constructor cannot be static
    		as, they are invoked every time we create objects.

L6-16:57 Can we have return type or any return statement with constructor?
    		No, we cannot have these.

L6-17:06 What is the use of private constructor in Java?
    		private members can only be accessed inside the class, where they are defined. So if we define
    		constructors private, then we can create objects of the Class only in inside that Class internally.
    		No other classes can create object for that.

    		-> So using private constructor we can restrict the caller from creating objects.

L6-19:19 Can a Constructor return any value ?
    		As we know constructors do not have any return type, So a constructor cannot return any explicit value.
    		However constructor returns the instance of the Class implicitly.

L6-19:47 Can an Abstract Class have a constructor?
    		Yes, an abstract Class can have a constructor.

L6-20:01 How we define a method in java?
    		Method is block of code which can be invoked by its name whenever required. In java we write method as,

    		<modifier> <return type> <method name>(datatype args){
    			//method body
    		}

L6-20:30 What is Method signature?
    		The method name and the data type of parameters it have is called as method signature. Like:
    		Method signature for method is,
    				findSum(int a ,int b).

L6-21:06 Does return type of the method is a part of method signature?
    		No, method signature only contain method name and type of arguments.

L6-22:02 What are Static methods?
    		We use static keyword to define static methods. Static methods are used to access static members.

    			Public static int get(){
    			}

    		-> To call static method:
    		 				Addition.get();

L6-22:22 Can we access instance variables inside Static methods?
    		Answer is No, we cannot access instance variable inside static blocks, static methods.
    		Static methods and static blocks can only access static members.

L6-23:24 What are method declarations?
    		When we do not define the body of method, and end it with a semi-colon then that is called method
    		declaration.

    		-> Method declarations are only used in abstract classes and interfaces.

L6-24:15 What are interfaces?
    		An Interface is actually blueprint of a class, which specifies what a Class must do. (not how)
    		i.e, Interfaces does not have implementations of methods, There are only method declarations
    		and all the methods are abstract and public by default.

    				interface InterfaceDemo{
    					void method1();
    					void method2();	//this is method declaration.
    				}

L6-25:57 What is a native method?
    		A native method is a method which is implemented in a non-java language, and is targeted for a
    		single machine type.

L6-26:35 Can we define any method as final?
    		Yes. Methods can be made as final.
    		-> You can define any method final if you want to restrict others to modify the implementation of the
    		 method.

L6-26:53 Can we create object for final class?
    		Yes, we can definitely create an object for final class.
    		Example is class:String. It is a final class.

//OOPS

L7-00:13 What is OOPS?
    OOPS stands for Object Orieted programming System.
    Object oriented programming is a Programming paradigm to write programs based on real world
    objects, in that world, the states and behaviour of an object are the variable and methods.

L7-01:15 What are the advantages of OOPS?
    These are the major advantages of OOPS:
    1. Simplicity:
    	   Since OOPS consists real world objects, so the program structure remains clear to everyone without
         any complexity.
    2. Modularity:
    	   In object oriented paradigm, each object forms a separate entity. For each object, their state,
         behaviour and other internal workings are decoupled from other parts of system.
    3. Modifiability:
    	   With OOPs programming it is easy to change the data representation and methods. Changes inside
         any particular Class do not affect any other part of the program.
    4. Extensibility:
    	   This is about adding New features by modifying some existing modules. OOPs allows to do that.
    5. Maintainability:
    	   The objects can be maintained by fixing problems easier.
    6. Reusability:
    	   Objects can be reused in different programs.

L7-02:37 What are the core concepts of oops?

    1. Data Hiding : hiding the internal data, Securing the internal data
    2. Abstraction : way to segregate implementations from other entities (Hiding internal implementation)
    3. Encapsulation : Grouping of data member and member functions together
    4. Inheritance : Inheritance is the process of creating a new Class from the existing class(Inheriting properties from a class)
    5. Association
    6. Composition
    7. Aggregation
    8. Polymorphism : a particular method that behaves different in different contexts

L8-00:02 What is the difference between Abstraction and Encapsulation?

    Abstraction is implemented using interfaces and abstract classes and Encapsulation is about wrapping
    data members and member functions. This is implemented using private, protected keywords.

    Encapsulation is a concept that is a mix of data hiding and Abstraction. We hide Data from
    unauthenticated access, and implementations from outside world.
    Abstraction is about not showing the internal implementations directly to any other class.

L8-01:04 What is difference between Abstract Class and Interface?

    1. In abstract class, we can have both abstract and concrete methods where as in Interface,
       we can only have abstract methods, they cannot have concrete methods.
       However we can have static, default and private methods in interface.

    2. We can extend only one Abstract Class at a time where as in case of interfaces, we can implement
       any number of interfaces at a time.

    3. In abstract class ‚Äòabstract‚Äô keyword is used to declare a method as abstract, where as in Interface
       all the methods are abstract by default, so no keyword is required to declare methods.

    4. Abstract Class can have static, final or static final variables with any access specifier
       where as in Interface, we can have only static final variable by default.

    So we can use interfaces, when we want to create a service requirement specification for any class.
    and we can use abstract classes to provide a base for subclasses to extend and implement the abstract
    methods and use the implemented methods which are defined in abstract class.

L8-04:09 How can we write static, private and default methods in interface?

L9-00:02 Can we have an abstract class without any abstract method?
    yes.

L9-00:21 Can we have a non-abstract class with abstract methods?
    No.

L9-00:39 Can we create constructor in abstract class?
    Yes. We can create constructor in abstract class. It does not give any compilation error,
    but as we cannot instantiate an Abstract Class so there is no use of creating it.

L9-00:58 What are the various types of inheritance?
    These are the types of inheritance:

    1. Single Inheritance: a single Class extends another class.

        class A{}
        class B extends A{}

    2. Multilevel Inheritance: in this there are multiple level of inheritance.

        class A{}
        class B extends A{}
        class C extends B{}

    3. Multiple Inheritance: A single Class extends more than 1 class.

    üëâüèª Java does not support this type of inheritance, because if a class extends more than one class. then there is chance
       of ambiguity problem if there is any method present with the same name.

       However we may implement more than one interfaces, so multiple inheritance is possible with
       interfaces.

    4. Hierarchical Inheritance: This is about having single base class, and multiple implementation
       classes. i.e, single parent multiple Child classes.

        class A{}
        class B extends A{}
        class C extends A{}

      Java allows this type of inheritance. We can extend a Class in more than one classes.

    5. Hybrid Inheritance: This is the combination of more than one type of inheritance. It is about having
       multiple base and multiple implementation classes.

       üëâüèª It is not supported in java, as we know multiple classes can extend a single Class but a
          single Class can not extend multiple classes.

    6. Cyclic inheritance: A Class extends itself. it is not available in java and not actually required.
       class A extends B{}
       class B extends A{}

       -> all the methods or attributes will be available for use to each other.
       Instead of doing this, one may merge these two classes. So Cyclic inheritance is not required.

L9-04:02 What is Diamond Problem in inheritance?
    In case of multiple inheritance, if a Class extends two classes, then there is chance of ambiguity
    problem. This ambiguity problem is called as Diamond Access problem.

L9-04:32 Why do not we have ambiguity problem with interfaces in case of multiple inheritance?
    We can implement more than one interface. So multiple inheritance is possible as interfaces
    only have declaration of methods, not implementation. If two interfaces have methods with same name,
    then these are only multiple declarations of that method. The implementation will be only one.
    So there is no chance of ambiguity problem.

L9-05:12 What happens when we have default methods of same signatures while implementing multiple interfaces?
    To resolve default method calls,
    We can explicitly specify which default method is to be used, in implementing class.

L9-07:21 What is the difference between Late Binding and Early Binding?
    Binding is the association of a method call with the method definition.
    i.e, when a method is called in java, the program control binds to the memory address where that
    method is defined.

    There are two types of binding in java,
    -> Early Binding | Static Binding
    -> Late Binding | Dynamic Binding

    üëâüèª The Early Binding happens at Compile time, and late binding at Runtime.

    üëâüèª In early binding the method definition and the method call are linked during compile time.
      And that can only happen when all information needed to call a method is available at the compile
      time only.
      -> private, static, and final methods - at compile time.

    üëâüèª In early binding, the Reference Type information is used to resolve method calls, whereas in
       Late binding object information is used.

    üëâüèª As method calls are resolved before run time, Static Binding results in faster execution of a
       program while Dynamic binding results in somewhat slower execution of code.

       However the major advantage of Dynamic binding or method overriding is its flexibility, as a single
       method can handle different type of objects at run time.
       This reduces the size of base code and makes code more readable.

L10-00:02 Can we overload and override static methods?
    Yes we can overload static methods. But we cannot override them. We can define same method with same
    method signature in other Class but that will not be Method overriding.
    Because static method calls are resolved statically, i.e, at compile time.
    And in method overriding, method calls are resolved dynamically.

L10-00:29 What is constructor overloading?
    Constructor overloading allows to have more than one constructor inside the class.
    So in Constructor overloading we have multiple constructors with different signatures, i.e,
    with different arguments.

L10-01:45 What is this keyword in java? ‚≠êÔ∏è
    'this' Keyword in java is a reference variable that refers to the current object.
    It holds the current state and behaviour for an object.

L10-05:47 What is super keyword?
    Super keyword is used to refer to Parent Class objects.
    -> When a Derived Class and Base Class has same data members then we may use super keyword to access
       the parent classMembers. same with the methods, we use super keyword with method calls to specify
       that parent Class method will be invoked.

L10-06:24 What is Constructor Chaining in java? ‚≠êÔ∏è
    In java, we can call one constructor from another. This is called Constructor Chaining.
    We have this and super keywords for that.
    -> this() is used to call another constructor from a constructor.
    -> super() is used to call the constructor of the super class from the constructor of base class.

L11-00:01 Can we overload main method?
    Apart from the fact that JVM always looks for the main method to launch the program, main method is
    just like other methods.
    We can overload main method too, But JVM never gonna call that overloaded method.
    -> To execute that method we need to call that from the main method only.

        public static void main(){
        //any implementation
        }

        public static void main(String[] args){
        	obj.main();
        }

L11-01:26 Can a final method be overloaded in java?
    Yes, final method can be overloaded but cannot be overridden.

L11-01:36 What is IS-A and HAS-A relationship?
    IS-A relationship implies inheritance. i.e, if class 'A' extends class 'B', then A is-a B.
    For example,

    -> There is a 'Teacher' Class which extends a 'Person'. So here a person is a teacher. and it is
    transitive, like if another class 'MathTeacher' extends 'Teacher' class, then also
    MathTeacher is-a Person.

    -> when a class 'A' has-a member reference variable of type 'B' then A has-a B. for Example,
    College has-a Teacher. This is also known as Aggregation.

L11-02:54 What is Stronger association: Composition or Aggregation?
    Composition is the stronger association than aggregation. Because in composition, the entities are
    highly dependent on each other.

L11-03:09 How OOPs is different than Procedural programming?
    -> Procedural language is based on functions but object oriented language is based on objects.

    -> Procedural language exposes the data for that program, whereas Object oriented language
    encapsulates the data.

    -> Procedural language follows top down programming paradigm, but OOp language follows bottom up
    programming paradigm.

    -> Procedural language is complex in nature, so it is difficult to modify, extend and maintain.
    but OOP language is less complex in nature so it is easier to modify, extend and maintain.

    -> Procedural language provides less scope of code reuse but object oriented language provides more
    scope of code reuse.
	
	
	============================================================
	
	
What is serialization?‚≠êÔ∏è
	Serialization is a mechanism of converting the state of an object into a byte stream.

what is Deserialization?‚≠êÔ∏è
	Deserialization is reverse of serialization.
	The reverse process of creating object from sequence of bytes is called deserialization.

How to make a Java class Serializable?
	By implementing Serializable interface.

How many methods Serializable has? If no method then what is the purpose of Serializable interface?
  It is a marker interface.The main purpose of using marker interface is to tell
  the compiler that treat differently the  object of the class which implemented marker interface.
  they are used to indicate something to compiler or JVM.

Which methods are used during Serialization and DeSerialization process in Java?
  we call ObjectOutputStream.writeObject(saveThisobject) and
  to deserialize that object we call ObjectInputStream.readObject() method.
  Call to writeObject() method trigger serialization process in java.
  one important thing to note about readObject() method is that it is used to read bytes
  from the persistence and to create object from those bytes and its return an Object
  which needs to be type cast to correct type.

What if we want to serialize or deserialize primitives?
  For every primitive corresponding method is there like writeInt(), readInt(), writeFloat() etc.

Write a program to serialize and deserialize an object.‚≠êÔ∏è

Can we serialize more than one object and write on same File?
  Yes

What does transient mean? why we use transient keyword?
  //While serializing you want some of the members not to serialize? How do you achieve it?
  Transient mean not to serialize.

What if we make static variable transient?
  Static variables are not part of object state.
  serialization is for objects.So static variables are not serialized.Thus no use of using transient.

Which kind of variables is not serialized during Java Serialization?‚≠êÔ∏è
  transient and static variables.

What if we make final variable transient?‚≠êÔ∏è
  It is useless to make a final variable transient.
  final variables participate in serialization directly by the value
  hence declaring a final variable as transient has no meaning.They will anyhow participate.

What do you have to take care if file to read is having more than one object?
  The order in which they were serialized.
  It should be same while deserializing. Otherwise we will get ClassCastException.

What if a member of class doesn't implement Serializable interface?
  //what is object graph?‚≠êÔ∏è
  If you try to serialize an object of a class which implements Serializable,
  but the object includes a reference to a non- Serializable class then a ‚ÄòNotSerializableException‚Äô will be thrown
  at runtime
  whenever we are serializing an object, set of all objects which are reachable
  from that object will be serialized automatically.
  this gp of objects is called object graph
  In object graph every object should be serializable.
  otherwise we will get ‚ÄòNotSerializableException‚Äô.

//Customized serialization

Can we customize Serialization process in Java?‚≠êÔ∏è
  yes. We can customize behavior of object in serialization and deserialization
  by implementing two methods in serializable class:

  private void writeObject(ObjectOutputStream os) throws Exception
  private void readObject(ObjectInputStream is) throws Exception

  we can do any kind of pre or post processing task inside these methods.
  These methods are callback methods, we can not call these methods as you can see
  they are private to avoid being inherited, overridden or overloaded, these are automatically called by jvm.

What is the need of customized serialization?
  To do any kind of pre or post processing task like encryption and decryption of fields which should be secured.
  or we can say to recover loss of information because of transient fields.

what if the child of serializable does not implement serializable and we try to serialize or deserialize object
of that class?
	All the child of serializable are by default serializable. Its inherited in child.

If a class is Serializable but its super class is not, what will be the state of the instance variables inherited
from super class after deserialization?
  If any variable is inherited from parent then jvm ignores the value and write the default value on file.
  Deserialization:
  jvm checks is the parent is serializable or not, if not then
  Jvm executes instance control flow and for that jvm always calls the no argument constructor.
  (can be default generated by compiler or provided by us)

What if the parent is not serializable and is not having no arg constructor?
  If no arg constructor is not there we will get InvalidClassException.

Suppose super class of a new class implement Serializable interface, how can we avoid new class to being serialized?
  To avoid Java serialization you can implement writeObject() and readObject() method in our serializable Class
  and throw NotSerializableException from those method.

//externalization

What is Externalizable? the difference between Serializable and Externalizable interface in Java?‚≠êÔ∏è
  Externalizable is an interface.(Not Marker)
  in serialization everything a taken care by jvm and programmer does not have any control..
	With serialization its not possible to save a part of file which can create performance problems
	so we have externalization.
  with externalization programmer have control instead of jvm,
	based on our requirement we can save a part or the full object.

  In externalization interface there are 2 methods:

  1.public void writeExternal(ObjectOutput oo) throws IOException   //ObjectOutput : Parent of ObjectOutputStream
  2.public void ReadExternal(ObjectInput io) throws IOException

  at the time of deserialization jvm again needs to create the object since the file only has a part of object
  it does not have the object and for that it needs no arg constructor
  thus externalizable class should contain public no arg constructor

Can we use transient keyword with externalization?
  Yes, but it has no affect.
  Its not required.

What is serialVersionUID and use of serialVersionUID?‚≠êÔ∏è
  jvm saves a unique identifier with every object based on the class file of the object while serializing.
  On receiver's machine while deserializing the jvm again generates the unique identifier for the same local class.
  If both does not match we will get InvaliClassException.else object will be deserialized.
  This unique identifier is serialVersion UID.

What are the drawbacks of using default serialVersion UID generated by jvm?
  The both machines which are serializing and deserializing the object have to use same machine that is same operating
  system, same java version, same vendor as to generate same serialVersion UID.
  Both sender and receiver have to use same version of class file, after serialization any change in
  that file at receiver side will lead to creation of different ID.Thus deserialization will not be performed.
  Jvm uses complex process to generate serialVersionUID , which may affect performance.

  so we can have our own serialVersionUID:
  private static final long serialVersionUID = 1L;

==================================================================


L1-01:00 What is enum?
    Enum is a special type in java that is used to define collection of constants.
    Enum of colours:

      enum Color{
	       Red,Green,Blue,White,Black;
      }

      This is how we declare enum.
      -> Semicolon is not mandatory if we are having only constants in enum.
      -> By using enum, we can create our own data type.
          üëâüèª Data type of Red is 'Color'.

L1-01:40 Where can we declare 'enum' type?
    Enum can be declared outside the class, and also inside the class.
    Note: Inside method we cannot create enum.

L1-01:55 How to access Enum constants?
    Every 'enum' constant is static, so We access 'enum' constants using the Enum name.

      System.out.println(Color.Red);

L1-02:14 How to get all constants of enum?
    For that we have values() method, that can be invoked with the enum name or enum instance.

    Color[] colors = Color.values();
    for(Color c : colors){
	     System.out.println(c);
     }

    üëâüèª Enum provides values() method implicitly. It is not present in Enum Class or Object class.

L1-02:41 Whats difference between the enum, Enum, and Enumeration?
    1. enum: It is a keyword to declare group of constants.

    2. Enum: It is base Class for all enums.
       üëâüèª Every 'enum' is direct child Class of Enum class.

    3. Enumeration: It is an Interface present in java.util Package.
                    It is a cursor that is used to get objects one by one from collection.

L1-05:33 Can an 'enum' be declared as final?
    No. enum is implicitly final. They can not be declared final explicitly.

L1-05:47 What modifiers are allowed to be used with enum?
    'enum' can be public, <default>, strictfp.
    If it is declared inside the class, then it can also be private, protected and static.

    üëâüèª 'enum' can not be abstract as they are implicitly final.

L1-06:08 Can an 'enum' extend any class?
    No. Every 'enum' is direct subClass of java.lang.Enum class.
    -> Since java does not provide support for multiple inheritance hence,
    üëâüèª It is not possible to extend Class with enum.

L1-06:26 Can 'enum' have implementation classes?
    No. enum cannot have subclasses because they are final implicitly.

06:44 Can 'enum' implement interfaces?
    Yes. enum is a type just like Class and interfaces.
    üëâüèª 'enum' can implement interfaces.

L1-07:03 Can we have Constructor in enum?
    Answer is yes! We can have Constructors as well as methods and variables inside the enum.

    Consider an enum Week, it can have constructor, other data members and methods:

      enum Week{
      	Sun,Mon,Tue,Wed,Thu,Fri,Sat;
      	int a;
      	Week(){

      	}
      	public void m1(){}
      }

L1-07:38 How constructors are invoked in enum?
    Answer is, every time we load the enum, the constructor is invoked.

    Every 'enum' constant is considered as 'enum' object.
    Whenever 'enum' gets loaded, for every 'enum' Constant, constructor will be invoked.

L2-00:00 Can we create 'enum' object explicitly?
    No. We can not create 'enum' object with new keyword.
    Because if we want to create any new object w of type Week enum, then we can declare w as enum constant! So there is no need of creating enum object explicitly ..
    -> Week w:
                enum Week{
                  Sun,Mon,Tue,Wed,Thu,Fri,Sat,w;
                }

                Week w = new Week(); ‚ùå

L2-00:32 Can we create parameterised constructors in enum? If yes then how to pass value to constructor?
    Yes, we can create parameterised constructors in enum.
        Sun("Holiday")

L2-04:18 Can 'enum' have abstract methods?
    No. Because Enum are final.

L2-04:37 Can we override toString() method for enum?
    Yes. We can override toString in Enum like any other class.
    -> But there is no need to overriding it, because Enum Class has already overridden the toString
    for every enum.

    Week w2 = Week.Wed;
    w2.toString();

    üëâüèª There is no need to call toString explicitly, because if we print any 'enum' constant,
       then by default it takes .toString() internally.

L2-05:43 Can we create 'enum' constant outside of enum?
    Answer is no, we can only create 'enum' constant inside its enum.

L2-06:08 Can constructors be public in enums?
    No constructors can not be public or protected either.

L2-06:18 What does ordinal() method do?
    Ordinal method returns order of the 'enum' constant.

L2-07:09 Can we use Enum with TreeSet or TreeMap in Java?
    Yes. We know we can use comparable types with treeSet or treeMap.
    üëâüèª Since Enum by default impalements Comparable interface, they can be used inside TreeSet or TreeMap.

L2-07:33 Can we use Enum in switch case in Java?
    Yes. Enum instances are constants so we can use them inside switch case.

      switch(Week){
                  case Sun:
                      System.out.println("Peaceful day");
                      break;
                  case Mon:
                      System.out.println("Back to work.");
                      break;
                  case Sat :
                      System.out.println("Party Time!");
                      break;
      	          default:
      		            System.out.println("Work Work Work.");
                  }

L2-08:07 Is Enum serializable in java?
    Yes, Java enums are automatically serializable as Enum Class implements Serializable interface.

L2-08:32 How to convert a String to Enum in Java?
    The String can be converted to 'enum' by using valueOf() method.
    The 'enum' type provides valueOf() method which takes a String as an argument and returns
    corresponding 'enum' object.

L2-10:03 What are benefits of using 'enum' in java?
    üëâüèª 'enum' are type safe, We cannot assign anything else other than those predefined constants of enum.

    üëâüèª 'enum' has its own namespace.

    üëâüèª We can use 'enum' with switch case..
	
	
	=========================================================================
	//File IO

L1-00:55 What is IO stream? What are the types of IO streams?
    Java I/O Stream is an abstraction that either produces or consumes data.
    Streams are flows of data, that we can either read from or write to!

    There are two types of I/O Streams:
    -> Character Streams
    -> Byte Streams

L1-01:57 What are the classes available for the different streams in java?
    For Character streams there are two abstract classes present in java IO ..
    1. java.io.Reader
    2. java.io.Writer

    Similarly for Byte Streams:
    1. java.io.InputStream
    2. java.io.OutputStream

L1-02:29 How these streams differ from each other?
    The InputStream classes receive data from various resources like
    a file, a pipe, a string, an array of bytes, and many other resources.

    OutputStream defines stream byte output. The destination may be
    an array of bytes, a file or any channel.

    Character streams have Reader and Writer:
    Which actually responsible for the flow of unicode characters. These takes information from a file
    and sends back to file!

L1-03:13 What happens if any error occurs in case?
    All of the stream classes throw IOException in case of any errors.

L1-03:26 How we can create any file?
    By creating an object of file class, we create a java file object to represent any resource.
      File f = new File("file.txt");
    To create a file in the current working directory:
      f.createNewFile();
    To create a new directory:
      f.mkdir();

L1-06:31 What if we use single slash while specifying file path?
    In windows, compiler takes single slash as escape. So single slash cannot be used to specify path..
    instead of that we can use '//'

    File f = new File("D://Documents//file.txt");

L1-07:14 How to select all text files under any directory?
    File.listFiles() method returns an array of File objects contained in the particular directory.

L2-00:01 What are different writers available for Character streams?
    There are three writers available for char streams:
      1.FileWriter
      2.BufferedWriter
      3.PrintWriter

L2-00:17 What is difference between fileWriter and BufferedWriter?
    With FileWriter we write character data or text data to any file.

      FileWriter fw = new FileWriter("File.txt");
      Fw.write("any string");
      fw.flush();
      fw.close();

    for appending the text that will be written with this object..

      FileWriter fw = new FileWriter("File.txt",true);

    BufferedWriter:
      BufferedWriter uses internal buffer to write data into file, other than this,
      It is similar to FileWriter.
      -> BufferedWriter can not communicate with file directly. We have to use other writer with it.

      BufferedWriter bw = new BufferedWriter(fw);
      bw.write("Writing with BufferedWriter");
      bw.flush();
      bw.close();

      In file writer we have to provide additional line separator (\n) to write in new line.
      But in BufferedWriter we have a method newLine() to provide line separator.

L2-03:55 When we had these two writers, What is the need of PrintWriter then?
    PrintWriter is the most enhanced writer. It overcomes the little limitations that we had with
    filewriter and bufferedWriter.
    For example,
      We were allowed to write char, string types only with those writers.
    -> What if we want to write data of different data types?
        PrintWriter allows us to do so.

    -> PrintWriter can communicate directly to file and also can communicate via any other writer..

          PrintWriter pw = new PrintWriter("File.txt");
          PrintWriter pw = new PrintWriter(new FileWriter("File.txt"));

          PrintWriter pw = new PrintWriter("abc.txt");
          pw.write(100);	//this will write d to file
          Pw.println(100);	//this will write int 100 and will separate line.
          pw.println(true);	//this will write boolean true and separate line..
          pw.flush();
          pw.close();

L2-05:05 Why we use flush() and close()?
    Flush() method is used to clear all the data characters stored in the buffer and clear the buffer.
    It flushes the stream so that we get assured that the data has properly written to file.

    Close() method is used to close the character stream and it releases system resources associated
    with the stream.

    Note that, flush method is applicable for all the Writers and close() is for all readers and writers..

L3-00:01 How to read any file?
    There are two readers to read the file:
      FileReader
      BufferedReader

L3-00:13 Difference between FileReader BufferedReader?
    FileReader reads the data from a file in the forms of characters..

    FileReader fr = new FR("abc.txt");
    char[] ch = new char[(int)f.length()];
    fr.read(ch);	//this will copy data from file into char array

    for(char ch1: ch){
      Sysout ch1;
    }

    With file reader we read data character by character, not line by line.
    For that, we have BufferedReader.

    BufferedReader allows us to read file by char and by line too.

      BufferedReader br = new BufferedReader(new FR("abc.txt"));
      String line = br.readLine();
      while(line!=null){
        System.out.println(line);
        line = br.readLine();
      }
      br.close();

    BufferedReader is most efficient reader for reading the file because it buffers the input from the
    specified file.

    -> Compared to FileReader, BufferedReader reads large chunks of data from file at once and
    keep this data in a buffer.
    When we ask for the next character or line of data, it gets retrieved from that buffer..
    This makes bufferedReader most efficient..

L5-00:06 Explain Hierarchy of Reader-Writer.

When to use ByteStreams?
    Byte oriented streams process data byte by byte, so byte stream is suitable for processing raw data
    like binary files.
    And when we have text files, then the character streams are useful.

When to use what: FileInputStream and FileReader.
    Both InputStream and Reader are used to read data from the source (either file or socket).

    InputStream is used to read binary data, while Reader is used to read text data, that is,
    Unicode characters.

    We should prefer Readers instead of InputStreams in case of text files.
    Buffered reader is suggested to use to read text files and FileInputStream is used to read raw
    streams of bytes from any source, which can be file or socket in java.

When to use what: FileOutputStream and FileWriter
    To write something to a file, we use FileOutputStream, FileWriter etc.
    With FileOutputStream class, we can write byte oriented as well as character oriented data.
    But Note that it is always preferred to use FileWriter/PrintWriter to write character data to file.

What are the FilterOutputStream and FilterInputStream?
    FilterOutputStream is another implementation of OutputStream.
    It further has different implementation classes: BufferedOutputStream
                                                     DataOutputStream
    It is used less individually.!

    Similarly, FilterInputStream have subclasses: BufferedInputStream
                                                  DataInputStream

Which superstructure Class allows reading data from an input byte stream in the format of primitive data
types?
    'DataInputStream' Class is used to read primitive data.
    Methods: readInt(), readByte(), readChar(), readDouble(), readBoolean()

    DataInputStream Class can not communicate directly to files.. we can use this as,

      DataInputStream dInput = new DataInputStream(new FileInputStream("File.txt"));

    and similarly, DataOutputStream is used to write Primitives to file.

How BufferedOutputStream is different from BufferedWriter?
    They are almost similar but BufferedOutputStream is used to write raw bytes whereas
    BufferedWriter writes characters.
    BufferedWriter: Provides buffering for Writer Instances which makes performance fast.
    BufferedOutputStream: Used for buffering output streams. Internally it uses buffer to store data.

    Methods to write data,
    write(int b): for writing specified byte to stream
    write(byte[] b, int off, int len): to write bytes from specified byte array starting with given offset

What is difference between InputStreamReader and BufferedReader?
    -> InputStreamReader creates a new stream object that can be used to read data from the specified source.
    It reads bytes and decodes them into characters.
    BufferedReader is an "abstraction" that reads text from a character-input stream.
    It 'buffers' characters so as to provide efficient reading of characters and lines.

    -> BufferedReader reads a couple of characters from the specified stream and stores it in a buffer.
    This makes input faster.
    InputStreamReader reads only one character from specified stream and remaining characters still remain
    in the stream.

What do you know about add-on classes?
    Add-on classes provides additional properties to the existing threads.
    Examples of classes: BufferedOutputStream , BufferedInputStream ,
    BufferedWriter ‚Äì buffers the stream and improves performance.

What class-add-on allows you to speed up reading / writing by using a buffer?
    java.io.BufferedInputStream (InputStream in) || BufferedInputStream (InputStream in, int size),

    java.io.BufferedOutputStream (OutputStream out) || BufferedOutputStream (OutputStream out, int size),

    java.io.BufferedReader (Reader r) || BufferedReader (Reader in, int sz),

    java.io.BufferedWriter (Writer out) || BufferedWriter (Writer out, int sz)

What classes allow you to convert byte streams to character and back?
    OutputStreamWriter
    InputStreamReader

Will this code compile?
ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File("newFile.txt")));
    Yes

Explain hierarchy of InputStream and OutputStream.


============================

What is NIO?‚≠êÔ∏è
    Non-Blocking I/O: Java provides a different way to work with I/O than the standard I/O Apis.
            -> NIO supports buffer-oriented and channel based approach for I/O operations.
            -> NIO introduced in java 1.4 and with JDK 7, NIO system is expanded.
            -> NIO is widely used in the File handling.

What are fundamental components of NIO?
    Java NIO has these fundamental components:
        1. Channels
        2. Buffers
        3. Selectors
        4. Non-blocking I/O

    Channel and Buffers: Data is written from a buffer to a channel and read from a channel to a buffer.

    Selectors: Selectors are used to monitor the multiple channels for the events like
               when data is arrived, connection is opened.

    Non-Blocking I/O: In NIO, Threads are allowed to go on and do something else in mean time of
                      performing any task.

In which Package the NIO classes are present?
    java.nio.*
      -> also there are sub-packages inside this Package.
            java.nio.charset
            java.nio.channels
            java.nio.file
            ..and many more

What is Channel? How many channels are there in java?‚≠êÔ∏è
    In NIO, channel is the medium to transport data efficiently.
    Channel in an Interface which provides access to low-level I/O services in a controlled way.
    Methods:
    1. isOpen() : this Tells whether or not this channel is open.
    2. close() : closes the channel.

    Channels:
      DatagramChannel
      SocketChannel
      FileChannel
      ServerSocketChannel

Which channel is used for reading data from files?
    FileChannel. It is used for reading data from files.
    -> We cannot create its object directly as it is an abstract class.
        for object creation - getChannel() method is used.

What other channels are used for?
    DatagramChannel is used to read and write data over the network via User Datagram protocol (UDP).
    SocketChannel can read write data over network via Transmission Control protocol (TCP).
    ServerSocketChannel allows user to listen the incoming TCP connections, same as a web server.

    Note that, for every incoming connection a socket channel is created.

What are NIO Buffers?‚≠êÔ∏è
    NIO buffers are used to make interaction with NIO channels.
    Block of memory into which we can write data, from which we can read data.
    üëâüèª In NIO system this memory block is wrapped with an NIO buffer object.

How many Buffers we have in java?
    There is a buffer type for every primitive type.
      1. CharBuffer
      2. DoubleBuffer
      3. IntBuffer
      4. LongBuffer
      5. ShortBuffer
      6. FloatBuffer

    There is ByteBuffer which is Mostly used buffer type.
      7. ByteBuffer

How to create ByteBuffer?
    To create ByteBuffer, we have to allocate a buffer. For that we invoke allocate() method,

    ByteBuffer b = ByteBuffer.allocate(capacity);

    to write data, we use put() method.

How to transfer data between channels and buffers?

    public class Demo {
    	public static void main(String[] args) throws IOException {
    		FileInputStream input = new FileInputStream("File1.txt");
    		ReadableByteChannel src = input.getChannel();

    		FileOutputStream output = new FileOutputStream("File2.txt");
    		WritableByteChannel dest = output.getChannel();

    		copy(src,dest);
    		input.close();
    		output.close();
    	}

    	private static void copy(ReadableByteChannel src, WritableByteChannel dest) throws IOException {
    		ByteBuffer b = ByteBuffer.allocate(1024*20);
    		while (src.read(b) != -1)
            {
                // The buffer is used to drained
                b.flip();
                // keep sure that buffer was fully drained
                while (b.hasRemaining())
                {
                    dest.write(b);
                }
                b.clear(); // Now the buffer is empty, ready for the filling
            }
    	}
    }
    This will write file1 data to file2.

Can we transfer data between channels?‚≠êÔ∏è
    Yes. In Java NIO we can directly transfer the data from one channel to another.

    Methods present in FileChannel:
      1. FileChannel.transferTo() method
      2. FileChannel.transferFrom() method

    The transferTo(position, count, target) method allows the data transfer from a FileChannel
    into some other channel.

    The transferFrom(src, position, count) method allows the data transfer from a source channel
    into the FileChannel.

What do you understand by Scattering reads and Gathering writes?‚≠êÔ∏è
    'Scattering read' is reading the data from a single channel into multiple buffers.
    'Gathering write' is writing the data from a multiple buffers into a single channel.

    We have ScatteringByteChannel, and GatheringByteChannel channels for this.

What Selectors are for?
    Selectors are used for handling multiple channels using a single thread.

    Selectors are created as,
    Selector selector = Selector.open();

    -> invoke the register() method on various channels objects to register our interest in various
    I/O events.

What is difference between IO and NIO?‚≠êÔ∏è
    -> The important distinction between IO and NIO is that,
    Original IO deals with data in streams, whereas NIO deals with data in blocks.
    IO is stream oriented and NIO is buffer oriented.

    -> IO streams are blocking whereas NIO can be blocking or non-blocking.

What do threads do in the mean time?
    Threads spend their time performing IO on other channels.
    -> In NIO a single thread can manage multiple channels of input and output.

    NIO have Selectors for selecting or registering in different channels.

-> you may also get asked some queries like,

If you have three sockets, then how many threads you will need to handle that?
    So answer to this is, using NIO we can operate on multiple channels using the same thread.

What is the byte order of ByteBuffer?
    Byte order is the order in which a multi-byte quantity is stored into the memory.
    There are two types of Byte order,
    1. Big-Endian
    2. Little-Endian

    üëâüèª Byte Buffer has big-endian as its default byte order..

What is the difference between Direct and Non-Direct buffer in java?‚≠êÔ∏è
    A byteBuffer is either direct or non-direct.
    If it is Direct byte buffer, then JVM will perform native I/O operations directly upon it.

    Direct byte buffer can be created:
    -> by invoking the allocateDirect() factory method of this class.
    -> by mapping a region of a file directly into memory.

    üëâüèª Non direct buffer is just a wrapper around byte array and it resides in Java heap memory,
      whereas Direct buffer resides outside of JVM and memory is not allocated from heap!

What is the memory mapped buffer in Java?
    MappedByteBuffer is a subclass of ByteBuffer, which is actually a Direct Byte Buffer whose content
    is a memory mapped region of a file.

    It is created by FileChannel.map() method.

What is the difference between ByteBuffer and CharBuffer in Java?
    A ByteBuffer is a buffer that holds (8-bit) byte values and CharBuffer holds (16 bit) char values..
	
	
	================================================================================
	
	
	-- Flow Control --

L1-00:24 What are Control flow statements?
    These are the statements which are used for -
      Decision making
      Looping
      Changing the control flow of a program on a particular case.

L1-00:58 Explain the if-else statement. | Explain how if-else changes the control flow of program?
    if-then:
      if(boolean arg){
        //code to be executed if condition returns true.
      }

      for example,
        public class Exercise{
          public static void main(String[] args){
	           int val= 25;
	           if(val<=30){
	              //execution will go inside the if block only if the condition returns true.
	           }
          }
        }

    else: else clause is optional.
        public class Exercise{
          public static void main(String[] args){
	           int val= 100;
	           if(val<=30){
	              //...
	           }else{
	              //...this block will be executed
	           }
          }
        }

L1-05:32 What if we have more than one or two conditions in program? Do we need to write if clause again and again?
    For this, we have else-if construct.

      public class Exercise{
        public static void main(String[] args){
	         int val= 50;
	         if(val<=30){
	            //...
	         }else if(val>30 && val<= 50){
	            //....this will be executed.
	         }else if(val>50 && val<=70){
	            //...
	         }else{
	            //...
	         }
        }
      }

    Note that, In java, if-else statement can only have boolean expressions as conditions.

L1-08:47 There is a boolean value a = true, and b = false. Can we put a=b condition in if block?
    boolean a = true;
    boolean b = false;
    if (a=b) {System.out.println("");}

    Yes we can put such conditions.

-----------------------------------------------------------------------------------------------------------

L1-10:29 Explain switch case. How it works and what object types can be used in the switch clause?
    The Switch clause provides several execution paths with case and default clause.
    -> Types it takes as switch values : byte, short, char, int and their wrapped versions.
                                         including enums and strings.

    for example,
      int yearsOfWorkingExperience = 8;
     	switch(yearsOfWorkingExperience){
          case 0:
              System.out.println("Fresher");
              break;
          case 1:
              System.out.println("Junior Developer");
              break;
          case 2:
              System.out.println("Developer");    //this will get executed
              break;
          case 3:
              System.out.println("Senior Developer");
              break;
          default:
              System.out.println("Team Lead");
      }

      There are 4 possible cases and one default case.

L1-11:43 How it works?
    switch statement evaluates each case expression for matching the value of variable that it is having.
    Then executes all the statements that are written inside that case if that case is matched.

    After executing the case we write break, so that the execution will break there and exits the switch
    statement.
    And if the none of the written cases are matched then the default block will get executed..

L1-12:43 What if we do not write the default block in switch statement?
    When none of the case will be matched, then nothing will get executed since default block is not there.

L1-13:17 What will happen when we forget to put break statement in case clause?
    In such case, it will continue executing all the cases which are written after that,
    until the break statement not found or until the end of switch statement.

        switch(yearsOfWorkingExperience){
          case 0:
            System.out.println("Fresher");
            break;
          case 1:
            System.out.println("Junior Developer");
          case 2:
            System.out.println("Developer");
          case 3:
            System.out.println("Senior Developer");
          break;
        }

L1-14:24 What if we put the default block in between the case labels?
    We can put the default block anywhere, compiler will not raise any error. But the best practice is
    we should always write the default block at the end.

L1-15:32 What is more preferable to use, switch over if-else or if-else over switch?
    The if-else statement is used
      -> when we need to check ranges of values or multiple conditions..

         public class Exercise{
           public static void main(String[] args){
   	         int val= 10;
   	         if((val%2)==0){
   	           System.out.println("Number is even");
   	         }else{
   	           System.out.println("Number is odd");
             }
           }

    The switch is used
      -> when we need to test a single variable against many single values.
         when several values executes the same code.

         int yearsOfWorkingExperience = 1;

   	     switch(yearsOfWorkingExperience){
   		      case 0:
   		         System.out.println("Fresher");
   		         break;
   		      case 1:
   		      case 2:
   		         System.out.println("Developer");
   		         break;
   		      case 3:
   		         System.out.println("Senior Developer");
   		         break;
   		      default:
   		         System.out.println("Team Lead");
   	     }


L2-00:16 What types of loops present in java?
   for, while, and do-while

   1. For loop: It provides a way to iterate over a range of values.
   We use for loop when we know in advance that how many times a task is going to be repeated.

       for(initialization; condition; incrementation/decrementation){
         //statements or code to be executed
       }

       for(int i=0;i<10;i++){
         System.out.println(i);
       }

L2-02:14 -> What if we do not put the condition in for loop?
       If we do not put the condition, then loop will execute for infinite times since we did not provide
       the condition and by default it will take true for that.

L2-03:27 -> What if we do not put the incrementation argument in for loop?
       If we do not increment the value then the 'i' will remain 0 always and will get printed for
       infinite times.

L2-03:36 -> What if we put break statement inside the for loop?
       In such case, the loop will get terminated.

   2. While loop: This loop is used to iterate a part of the program several times.
   We use while loop when the number of iteration is not fixed.

       We put only condition as argument with while.

       int i=10;
       while(i>1){		//condition
         System.out.println(i);	//statements
         i--;		//incrementing i
       }

   3. do-while loop: This loop is a variation of the while loop where the condition is evaluated at
   the bottom of the loop.
     do-while guarantees that the code will execute at least once!

     do{
       //statements to get executed
     } while(condition)

L2-07:38 What is enhanced for loop?
   The enhanced for loop is designed to iterate through all the elements of any collection,enum, array etc.

   for(DataType var : Collection){
     //statements to be executed
   }

L2-09:28 Except the arrays, which type of object we can iterate over using the foreach loop?
   We can iterate any object with this loop, which implements the Iterable interface.
   for example, lists, Set, and all the other collections.

L2-11:57 What are the difference between classic for loop and foreach loop?
    foreach is used to loop over a container which must implement the Iterable interface And
    there is no such requirement for the traditional for loop.

    for loop is present from the start in java, whereas the foreach loop was added in java in 1.5 version

    Enhanced for loop always executes in sequence.the counter is increased by one.
    whereas in for loop we can change the incremental step as per our requirement.

    foreach loop can iterate only in incremental order.
    But in traditional for loop we can also iterate in decremental order.
    By writing i-- in step counter to go backward

    we don't have the access to array index in foreach loop while iterating.
    so, we cannot replace the element at the given index.. whereas using for loop
    we are allowed to replace any element in the array by its index.

L2-14:23 How the foreach loop is different from foreach() method?
   Enhanced for loop or foreach loop iterates over the collection objects or the objects which implements
   Iterable interface. This is just the enhanced version of for loop..

   Foreach method is introduced in java 8, in the interface iterator as default method.
   We can iterate over any collection by passing the Lambda expression as argument.

L2-18:08 What are the various transfer statements used in java?
   There are six language constructs for transferring control in java:
   1. break: This statement is used to terminate the current loop or flow.

   2. continue: This is used to stop the execution in loop for the current iteration only.

   3. return: This statement stops the execution of a method and transfers the control to the caller.

   4. try-catch-finally

   5. throw

   6. assert
   
   
   ========================================================
   
   //java.lang Package

Why do not we need to Import java.lang Package in class?‚≠êÔ∏è
		We do not need to Import java.lang Package. Because all the classes in this Package are imported
		by default.

		Like the printing statement-> System.out.println();
		-> System is java.lang.System class, while using it we do not need to write its fully qualified name
		because all the public types present inside this Package are already imported in every class.

Name few classes of Package java.lang?
		Object, String, All wrapper classes, Math, System, StringBuffer, StringBuilder, Thread, Throwable etc.

What is the base Class for every class?‚≠êÔ∏è
		java.lang.Object Class is the base Class for every class.

Why java.lang.Object is the base class?
		Object Class contains the most common methods that are useful for any java object.
		equals(), hashCode() etc.
		-> To make those available for every object, Java made every Class to be child Class of object
		directly or indirectly.

What are the common methods provided by object class?

		equals() : used to compare two objects, returns true if any object is equals to this object.
							üëâüèª equals() method compares the references of object.

		toString(): The most useful method, returns a string representation of an object.

		hashCode(): this method returns the hash code value for the object.

		clone(): creates and returns a copy of the object.

		getClass(): this return the runtime Class of the object.

		wait(), notify(), notifyAll(): These methods do play a part in synchronizing the activities of
																	 independently running threads in any program.

		finalize(): This method is called by garbage collector on any object. This is deprecated since java 9.

What is a hashcode?‚≠êÔ∏è
		For every Object, JVM generates a unique number which is actually the Hash code.
		This hash value can be used to search object in a collection.

		üëâüèª it is not the address of the object its a distinct number thats generated for every object.

Whats the difference between an object and an object reference?
		An object is an instance of a class, and an object reference is a pointer to the object.
		There may be many references to a single object.

Is String a datatype?
		String in java is not a primitive data type like int, long, char. It is a Class or can be
		considered as user defined type.

		üëâüèª String Class is defined inside java.lang Package.

Is String a Wrapper class?
		No, It is not.

How String is different from a char array?
		1. Both of them contains the sequence of characters, but String is represented as a single data type,
			 whereas char array is a collection of data type.

	  2. Strings are immutable and characters are mutable.
			 That means, once we created the string, we cannot modify it by any way. If we modify the string,
			 it will always result in creating a new string.

				String str = "John";
				str = "Rohn";	//this will create a new string in memory.

		3. Various built in functions like sustring(): used to get a part of string,
			 charAt(): used to get particular character.
			 These functions can be used with string, but with charArrays, we cannot use them.

		4. String can be stored in memory in any way, while elements of character array are stored contiguously
			 in increasing memory locations.

		5. String are stored in string pool whereas, Character array are stored in heap memory in java.

What is the String pool?‚≠êÔ∏è
		The String constant pool is an area in java heap memory where Strings are stored.
		üëâüèª In String pool, there will be no String objects having the same content.

		    String s1 = "John";
				String s2 = "John";		//will point to same object

How these Statements are different?‚≠êÔ∏è
1. String str = "Basic";		2. String strr = new String("Basics");

	 String newStr = "Basic";

		These are the two ways to create string object:
		1. using string literal  //Inside String Pool
		2. using 'new' keyword.	 //Inside Heap Area

		char[] arr = {'a','b'};
		String object = new String(arr);

		String s = "Hello";
		String newS = s.concat(" programmer!");

		//intern()

		String reUseThis = newS.intern();

What is String Interning?‚≠êÔ∏è‚≠êÔ∏è

what intern() method is used for?‚≠êÔ∏è

How many objects will be created?
String s1 = "BasicsStrong";
String s2 = new String("BasicsStrong");
String s3 = "BasicsStrong";
String s4 = new String("Basics");
///String s5 = s4.concat(" here");

		Answer is 4, two object inside String constant pool.
		and two objects will be created inside heap Area.
		//SCP does not allow duplicate objects

Why String is Immutable and Final in java?
		There are many benefits of String because of its immutability:

		The concept of String constant pool is possible because String is immutable.
		This increases security because no one can change the string content.

		String are safe to use in multithreaded environment (where we work with multiple threads at a time),
		because we do not need any synchronization on Immutable objects.

		//All the Wrapper classes are immutable

Can we create an immutable class?‚≠êÔ∏è
		Yes! We can create immutable class, for that We just need to define the Class as final.
		we can define all the fields as final.
		-> By not providing any method to change the state of the object, we can create an immutable class.

Is String a keyword in java?
		Answer is no, String is not a keyword.

Which of them is better to store password? String or Char array?
		String is not recommended to use as data type for passwords, because of their immutability.
		string are stored in String pool, so once its created it always stays in the pool until Garbage
		collector erase it.
		So even though we are done with password kind stuff, it will be available in memory for the very long
		duration. It is a security risk, because anyone who is having access to memory can find password easily.

		While, char array can be modified and we can set elements of char array to blank or null once we are
		done with it. This controls the duration of it of being available in memory.

Difference between String, StringBuffer, StringBuilder.‚≠êÔ∏è
		StringBuilder and StringBuffer are another classes which are used to store strings.

		Strings are immutable and Final.
		Whenever we do String manipulation, it generates a new String and discards the older String for garbage
		collection.
		-> These generates a lot of garbage in heap, so java has provided String buffer and string builder
		classes that are mutable and can be used for string manipulation.

		StringBuffer vs StringBuilder:
		StringBuilder was introduced in java 1.5.
		StringBuffer operations are thread-safe and synchronized, whereas StringBuilder operations are not
		thread safe. That makes its performance faster than StringBuffer.

		Both StringBuffer and StringBuilder has not overriden the equals method
		so equals of object class gets executed which compares references.

How to check if two strings are equal?‚≠êÔ∏è
		There are two ways:
		Using == and using equals() method.

		== checks for the reference of the string.
    equals() checks for Value of strings.

		üëâüèª equals() method of object Class checks for references, but String has different
		implementation of equals() method. It checks for the values of the string.

What will be the output of this code snippet?

String s1 = "Basics";
StringBuffer s2 = new StringBuffer("Basics");
System.out.println(s1.equals(s2));

		Both s1 and s2 have the same value, but this statement will print false.
		Because the s2 is not of string type.

How to convert String to charArray and byteArray?
		To get char array from string, we use toCharArray() method,
		getBytes() is used to get bytes from a string.

What does substring() method do?
		substring() creates and returns a new string object by taking a portion of original string.

Which one of them is final class. String, StringBuffer or StringBuilder.
		All of them are final classes.

What is the use of Math class?
		Math Class provides the mathematical functions. like,
		sqrt(), exp(), log(), abs().

Can we instantiate the Math class?
		No its cannot be instantiated, because it is final and constructor is private.

Without creating instance how can we use Math Class functions?‚≠êÔ∏è
		All the methods of this Class are static. We can directly invoke them with classname.

What's Autoboxing and unboxing in java?‚≠êÔ∏è‚≠êÔ∏è
		Autoboxing and Unboxing : Introduced in Java 1.5 to automatically convert the primitive type into
		boxed primitive that is Object of Wrapper class.

		For example, when java automatically converts a primitive type like int, into respective wrapper
		Class Object, i.e, integer, then it is called Autoboxing.

		Unboxing is just the opposite case of it. Here, Integer object is converted into primitive int.

When do Autoboxing and Unboxing occur?‚≠êÔ∏è‚≠êÔ∏è
		Autoboxing and unboxing can occur wherever an object is expected and primitive is available.
		For example,
		A method expect an object argument but we pass primitive. In that case java automatically converts
		primitive into equal value object.

		-> The classic use of Autoboxing is in Collection. A collection is a group of objects.
		So auto boxing is used with collections to add primitive types..
		
		
		============================================
	
	