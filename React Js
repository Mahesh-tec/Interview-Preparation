1. useState
===========

ðŸ‘‰ Manages state in a functional component.

import React, { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

Explanation:
===========

Returns an array: [state, setState].

state is the current value.

setState is the function to update it.

Updating state causes the component to re-render.

==========================================================

2. useEffect
===========

Definition:
useEffect lets you perform side effects (like fetching data, subscriptions, timers, DOM updates).

Explanation:
============
Runs after every render by default.

Can run only on mount/unmount ([]).

Can re-run when dependencies change ([dep1, dep2]).

Cleanup function can prevent memory leaks.

import React, { useState, useEffect } from "react";

export default function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => setCount(c => c + 1), 1000);
    return () => clearInterval(interval); // cleanup
  }, []);

  return <h3>Timer: {count}</h3>;
}


==========================================

3. useContext
============

Definition:
useContext lets you consume values from Context API without prop drilling.

Explanation:
===========

Requires a Context created with createContext().

Provides values with Provider.

Access values inside components with useContext.

import React, { createContext, useContext } from "react";

const ThemeContext = createContext("light");

function Child() {
  const theme = useContext(ThemeContext);
  return <h3>Theme: {theme}</h3>;
}
export default function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}
======================================

4. useRef
========

Definition:
useRef creates a mutable reference that doesnâ€™t cause re-renders when updated.

Explanation:
===========

Can reference DOM elements.

Can store values across renders without re-rendering.

import React, { useRef } from "react";

export default function InputFocus() {
  const inputRef = useRef();

  const focusInput = () => inputRef.current.focus();

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
============================================
5. useMemo

Definition:
useMemo memoizes the result of a calculation.

Explanation:

Only recalculates when dependencies change.
Useful for expensive computations.

import React, { useState, useMemo } from "react";

export default function ExpensiveCalc() {
  const [num, setNum] = useState(0);
  const [count, setCount] = useState(0);

  const squared = useMemo(() => {
    console.log("Calculating...");
    return num * num;
  }, [num]);

  return (
    <div>
      <p>Squared: {squared}</p>
      <button onClick={() => setNum(num + 1)}>Change Num</button>
      <button onClick={() => setCount(count + 1)}>Change Count</button>
    </div>
  );
}
============================================================

6. useCallback

Definition:
useCallback memoizes a function to avoid re-creation on each render.

Explanation:

Prevents unnecessary re-renders of child components.
Returns the same function reference unless dependencies change.

import React, { useState, useCallback } from "react";

export default function CallbackExample() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
==========================================

7. useReducer:
==============

Definition:
useReducer is an alternative to useState for complex state logic.

Explanation:
Uses a reducer function (state, action) => newState.
Similar to Redux concept.
Good for state with multiple conditions.

import React, { useReducer } from "react";

const reducer = (state, action) => {
  switch (action.type) {
    case "inc": return { count: state.count + 1 };
    case "dec": return { count: state.count - 1 };
    default: return state;
  }
};

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: "inc" })}>+</button>
      <button onClick={() => dispatch({ type: "dec" })}>-</button>
    </div>
  );
}
===============================================================


8. useLayoutEffect:
====================

Definition:
useLayoutEffect runs synchronously after DOM mutations but before the browser paints.

Explanation:

Similar to useEffect, but blocks painting until execution completes.
Used when you need to measure DOM size/position.

import React, { useLayoutEffect, useRef } from "react";

export default function Box() {
  const boxRef = useRef();

  useLayoutEffect(() => {
    console.log("Box width:", boxRef.current.offsetWidth);
  }, []);

  return <div ref={boxRef} style={{ width: "200px", height: "50px", background: "skyblue" }}>Box</div>;
}
====================================================================


9. useImperativeHandle

Definition:
Customizes what parent components can access when using ref.

Explanation:

Used with forwardRef.
Useful when exposing specific methods from child to parent.

Example:
import React, { useRef, forwardRef, useImperativeHandle } from "react";

const Child = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({
    sayHello() {
      alert("Hello from Child!");
    }
  }));
  return <h3>Child Component</h3>;
});

export default function Parent() {
  const childRef = useRef();

  return (
    <div>
      <Child ref={childRef} />
      <button onClick={() => childRef.current.sayHello()}>Call Child</button>
    </div>
  );
}
=======================================

15. Custom Hooks
================

Definition:
Custom hooks are user-defined functions that use other hooks.

Explanation:

Encapsulates reusable logic.
Always start with use.

Example:
import React, { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);

  return data;
}

export default function App() {
  const user = useFetch("https://jsonplaceholder.typicode.com/users/1");
  return <div>{user ? user.name : "Loading..."}</div>;
}
=========================================================


Example of Student Funtion:
===========================

import React, { useState } from "react";

export default function Student() {
  const [student, setStudent] = useState({
    name: "",
    rollNo: "",
    studentClass: "",
    email: ""
  });

  // handle input change
  const handleChange = (e) => {
    const { name, value } = e.target;
    setStudent({
      ...student,
      [name]: value
    });
  };

  // handle form submit
  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Student Details:
    Name: ${student.name}
    Roll No: ${student.rollNo}
    Class: ${student.studentClass}
    Email: ${student.email}`);
  };

  return (
    <div style={{ margin: "20px", maxWidth: "400px" }}>
      <h2>Student Form</h2>
      <form onSubmit={handleSubmit}>
        {/* Name */}
        <div style={{ marginBottom: "10px" }}>
          <label>Name: </label><br />
          <input
            type="text"
            name="name"
            value={student.name}
            onChange={handleChange}
            required
          />
        </div>

        {/* Roll No */}
        <div style={{ marginBottom: "10px" }}>
          <label>Roll No: </label><br />
          <input
            type="text"
            name="rollNo"
            value={student.rollNo}
            onChange={handleChange}
            required
          />
        </div>

        {/* Class */}
        <div style={{ marginBottom: "10px" }}>
          <label>Class: </label><br />
          <input
            type="text"
            name="studentClass"
            value={student.studentClass}
            onChange={handleChange}
            required
          />
        </div>

        {/* Email */}
        <div style={{ marginBottom: "10px" }}>
          <label>Email: </label><br />
          <input
            type="email"
            name="email"
            value={student.email}
            onChange={handleChange}
            required
          />
        </div>
      <button type="submit">Submit</button>
      </form>
    </div>
  );
}

===========================================
Scenario Based questions:
=========================

1. Does updating state in Child update Parent automatically?

âŒ No, it doesnâ€™t.
React follows one-way data flow (top-down):
Parent â†’ Child: Data is passed down as props.
Child â†’ Parent: A child cannot directly update parent state. Instead, the parent must pass a callback function to the child.
When the child calls that function, the parent updates its own state.

import React, { useState } from "react";

// Child Component (B)
function Child({ updateParent }) {
  const handleClick = () => {
    updateParent("World"); // send "World" to parent
  };

  return (
    <div>
      <h3>Child B</h3>
      <button onClick={handleClick}>Update Parent</button>
    </div>
  );
}

// Parent Component (A)
export default function Parent() {
  const [message, setMessage] = useState("Hello"); // parent variable

  return (
    <div>
      <h2>Parent A</h2>
      <p>Message: {message}</p>

      {/* Pass parent's updater to child */}
      <Child updateParent={setMessage} />
    </div>
  );
}

How this works:

1.Parent A starts with message = "Hello".

2.It passes setMessage (state updater) as updateParent to Child B.

3.Child B calls updateParent("World").

4.Parent Aâ€™s state changes â†’ "Hello" â†’ "World".

5.React re-renders Parent and updates the UI.


=========================================================

What is React Context API?

The React Context API is a built-in way to share state and functions across components without passing props manually (prop drilling).

It provides a mechanism to make values global to a component tree.

Think of it like a shared box: Parent puts data inside, and any Child (no matter how deep) can take or update it.

ðŸ”¹ Key Concepts

React.createContext()

Creates a Context object.

Think of it as the â€œcontainerâ€ for shared data.

Context.Provider

Wraps components and provides data (state, functions, objects).

Context.Consumer

Used inside a child to read or update the data from the provider.

Without hooks, we use this Consumer pattern.

Example: Parent A (Hello) â†’ Child B updates it to World (via Context API)

import React, { createContext, Component } from "react";

// 1. Create Context
const MessageContext = createContext();

// 2. Parent Component
class Parent extends Component {
  state = { message: "Hello" };

  setMessage = (msg) => {
    this.setState({ message: msg });
  };

  render() {
    return (
      // 3. Provide state + updater via Context
      <MessageContext.Provider
        value={{ message: this.state.message, setMessage: this.setMessage }}
      >
        <h2>Parent: {this.state.message}</h2>
        <Child />
      </MessageContext.Provider>
    );
  }
}

// 4. Child Component
class Child extends Component {
  render() {
    return (
      // 5. Consume context values
      <MessageContext.Consumer>
        {({ message, setMessage }) => (
          <div>
            <p>Child sees: {message}</p>
            <button onClick={() => setMessage("World")}>
              Update Parent
            </button>
          </div>
        )}
      </MessageContext.Consumer>
    );
  }
}

export default Parent;


How it works:

MessageContext is created.

Parent wraps children inside MessageContext.Provider.

It passes { message, setMessage } as the shared value.

Child uses MessageContext.Consumer.

It receives { message, setMessage }.

It can read parentâ€™s message and call setMessage to update it.

When child clicks button â†’ setMessage("World") â†’ Parent state updates â†’ re-render â†’ new value flows down.

ðŸ”¹ Why use Context API?

âœ… Avoids prop drilling (passing props multiple levels deep).
âœ… Allows multiple children (siblings, grandchildren) to access/update the same state.
âœ… No need for hooks (you can use Consumer in class components).

==========================================================================

2.Problem Definition

In JavaScript, code runs synchronously by default (line by line).
But when we call a REST API (fetch, axios), it is asynchronous â€” it doesnâ€™t wait.
So if we write:
example :

console.log("Step 1");
fetch("https://jsonplaceholder.typicode.com/posts/1");
console.log("Step 2");

output:

Step 1
Step 2
(API response comes later)


Solution: Using async/await:
============================
// 1 to 6: Normal synchronous JS
console.log("Step 1");
console.log("Step 2");
console.log("Step 3");
console.log("Step 4");
console.log("Step 5");
console.log("Step 6");

// Wrap in async function
async function runFlow() {
  try {
    // 7 & 8: Two REST API calls executed in parallel
    let [response1, response2] = await Promise.all([
      fetch("https://jsonplaceholder.typicode.com/posts/1"),
      fetch("https://jsonplaceholder.typicode.com/posts/2")
    ]);

    // Wait for JSON parsing
    let data1 = await response1.json();
    let data2 = await response2.json();

    console.log("API 1 Response:", data1);
    console.log("API 2 Response:", data2);

    // 9 to 10: Run only after both API responses are ready
    console.log("Step 9 - Processing both APIs...");
    console.log("Step 10 - Finished!");
  } catch (error) {
    console.error("Error occurred:", error);
  }
}

// Call function
runFlow();




How this works:
===============
Lines 1â€“6 â†’ run normally.
At line 7 â†’ API is called.
await makes JavaScript pause here until API response comes back.
Once response is ready â†’ lines 9â€“10 execute.
If API fails â†’ error is caught in catch.


============
Approach 2: Using .then() (older style):
========================================

// 1 to 6: Normal synchronous JS
console.log("Step 1");
console.log("Step 2");
console.log("Step 3");
console.log("Step 4");
console.log("Step 5");
console.log("Step 6");

// Step 7 & 8: Parallel API calls with Promise.all
Promise.all([
  fetch("https://jsonplaceholder.typicode.com/posts/1"),
  fetch("https://jsonplaceholder.typicode.com/posts/2")
])
  .then(([res1, res2]) => Promise.all([res1.json(), res2.json()]))
  .then(([data1, data2]) => {
    console.log("API 1 Response:", data1);
    console.log("API 2 Response:", data2);

    // Step 9 & 10: Run only after API responses
    console.log("Step 9 - Processing both APIs...");
    console.log("Step 10 - Finished!");
  })
  .catch((err) => console.error("Error:", err));



       
