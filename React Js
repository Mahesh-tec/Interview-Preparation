1. useState
===========

👉 Manages state in a functional component.

import React, { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

Explanation:
===========

Returns an array: [state, setState].

state is the current value.

setState is the function to update it.

Updating state causes the component to re-render.

==========================================================

2. useEffect
===========

Definition:
useEffect lets you perform side effects (like fetching data, subscriptions, timers, DOM updates).

Explanation:
============
Runs after every render by default.

Can run only on mount/unmount ([]).

Can re-run when dependencies change ([dep1, dep2]).

Cleanup function can prevent memory leaks.

import React, { useState, useEffect } from "react";

export default function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => setCount(c => c + 1), 1000);
    return () => clearInterval(interval); // cleanup
  }, []);

  return <h3>Timer: {count}</h3>;
}


==========================================

3. useContext
============

Definition:
useContext lets you consume values from Context API without prop drilling.

Explanation:
===========

Requires a Context created with createContext().

Provides values with Provider.

Access values inside components with useContext.

import React, { createContext, useContext } from "react";

const ThemeContext = createContext("light");

function Child() {
  const theme = useContext(ThemeContext);
  return <h3>Theme: {theme}</h3>;
}
export default function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}
======================================

4. useRef
========

Definition:
useRef creates a mutable reference that doesn’t cause re-renders when updated.

Explanation:
===========

Can reference DOM elements.

Can store values across renders without re-rendering.

import React, { useRef } from "react";

export default function InputFocus() {
  const inputRef = useRef();

  const focusInput = () => inputRef.current.focus();

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
============================================
5. useMemo

Definition:
useMemo memoizes the result of a calculation.

Explanation:

Only recalculates when dependencies change.
Useful for expensive computations.

import React, { useState, useMemo } from "react";

export default function ExpensiveCalc() {
  const [num, setNum] = useState(0);
  const [count, setCount] = useState(0);

  const squared = useMemo(() => {
    console.log("Calculating...");
    return num * num;
  }, [num]);

  return (
    <div>
      <p>Squared: {squared}</p>
      <button onClick={() => setNum(num + 1)}>Change Num</button>
      <button onClick={() => setCount(count + 1)}>Change Count</button>
    </div>
  );
}
============================================================

6. useCallback

Definition:
useCallback memoizes a function to avoid re-creation on each render.

Explanation:

Prevents unnecessary re-renders of child components.
Returns the same function reference unless dependencies change.

import React, { useState, useCallback } from "react";

export default function CallbackExample() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
==========================================

7. useReducer:
==============

Definition:
useReducer is an alternative to useState for complex state logic.

Explanation:
Uses a reducer function (state, action) => newState.
Similar to Redux concept.
Good for state with multiple conditions.

import React, { useReducer } from "react";

const reducer = (state, action) => {
  switch (action.type) {
    case "inc": return { count: state.count + 1 };
    case "dec": return { count: state.count - 1 };
    default: return state;
  }
};

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: "inc" })}>+</button>
      <button onClick={() => dispatch({ type: "dec" })}>-</button>
    </div>
  );
}
===============================================================


8. useLayoutEffect:
====================

Definition:
useLayoutEffect runs synchronously after DOM mutations but before the browser paints.

Explanation:

Similar to useEffect, but blocks painting until execution completes.
Used when you need to measure DOM size/position.

import React, { useLayoutEffect, useRef } from "react";

export default function Box() {
  const boxRef = useRef();

  useLayoutEffect(() => {
    console.log("Box width:", boxRef.current.offsetWidth);
  }, []);

  return <div ref={boxRef} style={{ width: "200px", height: "50px", background: "skyblue" }}>Box</div>;
}
====================================================================


9. useImperativeHandle

Definition:
Customizes what parent components can access when using ref.

Explanation:

Used with forwardRef.
Useful when exposing specific methods from child to parent.

Example:
import React, { useRef, forwardRef, useImperativeHandle } from "react";

const Child = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({
    sayHello() {
      alert("Hello from Child!");
    }
  }));
  return <h3>Child Component</h3>;
});

export default function Parent() {
  const childRef = useRef();

  return (
    <div>
      <Child ref={childRef} />
      <button onClick={() => childRef.current.sayHello()}>Call Child</button>
    </div>
  );
}
=======================================

15. Custom Hooks
================

Definition:
Custom hooks are user-defined functions that use other hooks.

Explanation:

Encapsulates reusable logic.
Always start with use.

Example:
import React, { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);

  return data;
}

export default function App() {
  const user = useFetch("https://jsonplaceholder.typicode.com/users/1");
  return <div>{user ? user.name : "Loading..."}</div>;
}
=========================================================


Example of Student Funtion:
===========================

import React, { useState } from "react";

export default function Student() {
  const [student, setStudent] = useState({
    name: "",
    rollNo: "",
    studentClass: "",
    email: ""
  });

  // handle input change
  const handleChange = (e) => {
    const { name, value } = e.target;
    setStudent({
      ...student,
      [name]: value
    });
  };

  // handle form submit
  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Student Details:
    Name: ${student.name}
    Roll No: ${student.rollNo}
    Class: ${student.studentClass}
    Email: ${student.email}`);
  };

  return (
    <div style={{ margin: "20px", maxWidth: "400px" }}>
      <h2>Student Form</h2>
      <form onSubmit={handleSubmit}>
        {/* Name */}
        <div style={{ marginBottom: "10px" }}>
          <label>Name: </label><br />
          <input
            type="text"
            name="name"
            value={student.name}
            onChange={handleChange}
            required
          />
        </div>

        {/* Roll No */}
        <div style={{ marginBottom: "10px" }}>
          <label>Roll No: </label><br />
          <input
            type="text"
            name="rollNo"
            value={student.rollNo}
            onChange={handleChange}
            required
          />
        </div>

        {/* Class */}
        <div style={{ marginBottom: "10px" }}>
          <label>Class: </label><br />
          <input
            type="text"
            name="studentClass"
            value={student.studentClass}
            onChange={handleChange}
            required
          />
        </div>

        {/* Email */}
        <div style={{ marginBottom: "10px" }}>
          <label>Email: </label><br />
          <input
            type="email"
            name="email"
            value={student.email}
            onChange={handleChange}
            required
          />
        </div>
      <button type="submit">Submit</button>
      </form>
    </div>
  );
}

===========================================
Scenario Based questions:
=========================

1. Does updating state in Child update Parent automatically?

❌ No, it doesn’t.
React follows one-way data flow (top-down):
Parent → Child: Data is passed down as props.
Child → Parent: A child cannot directly update parent state. Instead, the parent must pass a callback function to the child.
When the child calls that function, the parent updates its own state.

import React, { useState } from "react";

// Child Component (B)
function Child({ updateParent }) {
  const handleClick = () => {
    updateParent("World"); // send "World" to parent
  };

  return (
    <div>
      <h3>Child B</h3>
      <button onClick={handleClick}>Update Parent</button>
    </div>
  );
}

// Parent Component (A)
export default function Parent() {
  const [message, setMessage] = useState("Hello"); // parent variable

  return (
    <div>
      <h2>Parent A</h2>
      <p>Message: {message}</p>

      {/* Pass parent's updater to child */}
      <Child updateParent={setMessage} />
    </div>
  );
}

How this works:

1.Parent A starts with message = "Hello".

2.It passes setMessage (state updater) as updateParent to Child B.

3.Child B calls updateParent("World").

4.Parent A’s state changes → "Hello" → "World".

5.React re-renders Parent and updates the UI.


=========================================================

What is React Context API?

The React Context API is a built-in way to share state and functions across components without passing props manually (prop drilling).

It provides a mechanism to make values global to a component tree.

Think of it like a shared box: Parent puts data inside, and any Child (no matter how deep) can take or update it.

🔹 Key Concepts

React.createContext()

Creates a Context object.

Think of it as the “container” for shared data.

Context.Provider

Wraps components and provides data (state, functions, objects).

Context.Consumer

Used inside a child to read or update the data from the provider.

Without hooks, we use this Consumer pattern.

Example: Parent A (Hello) → Child B updates it to World (via Context API)

import React, { createContext, Component } from "react";

// 1. Create Context
const MessageContext = createContext();

// 2. Parent Component
class Parent extends Component {
  state = { message: "Hello" };

  setMessage = (msg) => {
    this.setState({ message: msg });
  };

  render() {
    return (
      // 3. Provide state + updater via Context
      <MessageContext.Provider
        value={{ message: this.state.message, setMessage: this.setMessage }}
      >
        <h2>Parent: {this.state.message}</h2>
        <Child />
      </MessageContext.Provider>
    );
  }
}

// 4. Child Component
class Child extends Component {
  render() {
    return (
      // 5. Consume context values
      <MessageContext.Consumer>
        {({ message, setMessage }) => (
          <div>
            <p>Child sees: {message}</p>
            <button onClick={() => setMessage("World")}>
              Update Parent
            </button>
          </div>
        )}
      </MessageContext.Consumer>
    );
  }
}

export default Parent;


How it works:

MessageContext is created.

Parent wraps children inside MessageContext.Provider.

It passes { message, setMessage } as the shared value.

Child uses MessageContext.Consumer.

It receives { message, setMessage }.

It can read parent’s message and call setMessage to update it.

When child clicks button → setMessage("World") → Parent state updates → re-render → new value flows down.

🔹 Why use Context API?

✅ Avoids prop drilling (passing props multiple levels deep).
✅ Allows multiple children (siblings, grandchildren) to access/update the same state.
✅ No need for hooks (you can use Consumer in class components).

==========================================================================

2.Problem Definition

In JavaScript, code runs synchronously by default (line by line).
But when we call a REST API (fetch, axios), it is asynchronous — it doesn’t wait.
So if we write:
example :

console.log("Step 1");
fetch("https://jsonplaceholder.typicode.com/posts/1");
console.log("Step 2");

output:

Step 1
Step 2
(API response comes later)


Solution: Using async/await:
============================
// 1 to 6: Normal synchronous JS
console.log("Step 1");
console.log("Step 2");
console.log("Step 3");
console.log("Step 4");
console.log("Step 5");
console.log("Step 6");

// Wrap in async function
async function runFlow() {
  try {
    // 7 & 8: Two REST API calls executed in parallel
    let [response1, response2] = await Promise.all([
      fetch("https://jsonplaceholder.typicode.com/posts/1"),
      fetch("https://jsonplaceholder.typicode.com/posts/2")
    ]);

    // Wait for JSON parsing
    let data1 = await response1.json();
    let data2 = await response2.json();

    console.log("API 1 Response:", data1);
    console.log("API 2 Response:", data2);

    // 9 to 10: Run only after both API responses are ready
    console.log("Step 9 - Processing both APIs...");
    console.log("Step 10 - Finished!");
  } catch (error) {
    console.error("Error occurred:", error);
  }
}

// Call function
runFlow();




How this works:
===============
Lines 1–6 → run normally.
At line 7 → API is called.
await makes JavaScript pause here until API response comes back.
Once response is ready → lines 9–10 execute.
If API fails → error is caught in catch.


============
Approach 2: Using .then() (older style):
========================================

// 1 to 6: Normal synchronous JS
console.log("Step 1");
console.log("Step 2");
console.log("Step 3");
console.log("Step 4");
console.log("Step 5");
console.log("Step 6");

// Step 7 & 8: Parallel API calls with Promise.all
Promise.all([
  fetch("https://jsonplaceholder.typicode.com/posts/1"),
  fetch("https://jsonplaceholder.typicode.com/posts/2")
])
  .then(([res1, res2]) => Promise.all([res1.json(), res2.json()]))
  .then(([data1, data2]) => {
    console.log("API 1 Response:", data1);
    console.log("API 2 Response:", data2);

    // Step 9 & 10: Run only after API responses
    console.log("Step 9 - Processing both APIs...");
    console.log("Step 10 - Finished!");
  })
  .catch((err) => console.error("Error:", err));

=============================================================

Componets in React Js:
=====================

They are:


1. Class Components in React:
=============================
A Class Component in React is a JavaScript class that extends React.Component and must implement a render() method that returns JSX.
They can hold state, accept props, and use lifecycle methods to manage the component’s behavior over time.

Key Points:
============

1.Must extend React.Component.
2.Must have a render() method that returns JSX.
3.Can use props → to receive data from parent components.
4.Can use state → to manage internal data that changes over time.
5.Have access to lifecycle methods, such as:
    => componentDidMount() → runs after the component is mounted.
    => componentDidUpdate() → runs after state/props are updated.
    => componentWillUnmount() → runs before the component is removed.

import React, { Component } from "react";

class Welcome extends Component {
  // Constructor is used to initialize state and bind methods
  constructor(props) {
    super(props);

    // State: component’s own data
    this.state = {
      count: 0
    };
  }

  // Example method to update state
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  // Lifecycle method: runs once after component mounts
  componentDidMount() {
    console.log("Welcome Component Mounted!");
  }

  // Required method: must return JSX
  render() {
    return (
      <div>
        {/* Props are received from parent */}
        <h1>Hello, {this.props.name}!</h1>
        
        {/* State usage */}
        <p>Count: {this.state.count}</p>
        
        {/* Event handler */}
        <button onClick={this.increment}>Increase</button>
      </div>
    );
  }
}

export default Welcome;

===========================================
2. Functional Components in React:
==================================
A Functional Component in React is a plain JavaScript function that returns JSX to describe the UI.
Originally, functional components were called stateless components, because they could only receive data through props and could not manage state or use lifecycle methods.

However, since the introduction of React Hooks (React v16.8), functional components can now:

Manage state (useState)
Handle side effects (useEffect)
Use other React features (context, refs, memoization, etc.)

Example:
========
import React, { useState, useEffect } from 'react';

function Counter({ name }) {
  // state with useState hook
  const [count, setCount] = useState(0);

  // lifecycle with useEffect hook
  useEffect(() => {
    console.log("✅ Component Mounted or Updated");

    // cleanup (like componentWillUnmount)
    return () => {
      console.log("🛑 Component Will Unmount");
    };
  }, [count]);

  return (
    <div>
      <h2>Hello, {name} 👋</h2>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}

export default Counter;
===================================================================

3. Presentational (Stateless) Components in React

A Presentational Component (also called a Stateless Component) in React is a component whose primary purpose is to render UI.
It is focused on how things look, rather than how things work.

These components:
Receive data and callbacks exclusively through props.
Do not manage internal state (before hooks, hence called “stateless”).
Are typically written as functional components because they only need to return JSX.

Example:
========

import React from 'react';

// Presentational Component
const UserCard = ({ name, age, onClick }) => {
  return (
    <div style={{ border: "1px solid gray", padding: "10px", margin: "10px" }}>
      <h3>{name}</h3>
      <p>Age: {age}</p>
      <button onClick={onClick}>Show Details</button>
    </div>
  );
};

export default UserCard;
===============================================================

4. Container (Stateful / Smart) Components in React:
====================================================

A Container Component (also known as a Stateful Component or Smart Component) in React is responsible for managing data, state, and application logic.
Unlike Presentational Components, which only render UI, Container Components handle how things work: 
fetching data, updating state, and passing props to child components.

Example:
========
import React, { Component } from 'react';
import UserCard from './UserCard'; // Presentational Component

class UserContainer extends Component {
  constructor(props) {
    super(props);
    this.state = {
      user: { name: "Mahesh", age: 25 }
    };
  }

  showDetails = () => {
    alert(`User: ${this.state.user.name}, Age: ${this.state.user.age}`);
  };

  render() {
    return (
      <UserCard 
        name={this.state.user.name} 
        age={this.state.user.age} 
        onClick={this.showDetails} 
      />
    );
  }
}

export default UserContainer;
================================================

5. Higher-Order Components (HOC) in React:
==========================================

A Higher-Order Component (HOC) in React is an advanced design pattern where a function takes a component as input and returns a new enhanced component.
HOCs are used to reuse component logic, separate cross-cutting concerns (like authentication, logging, caching),
and apply additional functionality to components without modifying their source code.

==============================================================================================

6. Controlled Components in React:
==================================

A Controlled Component in React is a component where the form data is controlled by React state rather than the DOM.
In other words, the source of truth for the input value resides in the component’s state, 
and changes to the input are handled through event handlers (like onChange).

Example:

import React, { useState } from 'react';

function ControlledForm() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value); // update state
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted Name: ${name}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Enter Name: 
        <input 
          type="text" 
          value={name}   // controlled by state
          onChange={handleChange} 
        />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default ControlledForm;

=============================================

7. Uncontrolled Components in React:
===================================

An Uncontrolled Component in React is a component where the form data is handled by the DOM itself, instead of being fully controlled by React state.
Instead of binding the value of form inputs to state, React uses refs to access the DOM values when needed.

import React, { useRef } from 'react';

function UncontrolledForm() {
  const nameInput = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted Name: ${nameInput.current.value}`); // get value directly from DOM
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Enter Name: 
        <input type="text" ref={nameInput} /> {/* uncontrolled input */}
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default UncontrolledForm;
==========================================================

Class Components vs Functional Components in Real-Time Banking Applications:

Class Components:
================

Best used when:

Maintaining or upgrading legacy React code (before Hooks).
You need fine-grained lifecycle methods (though useEffect now covers most cases).
Your team is more familiar with classes than hooks.
Examples in Banking Apps:

Old transaction dashboards still using class-based state.
Legacy authentication flows (JWT sessions, login pages).
Existing form-heavy modules (like account opening forms) if written before Hooks.

✅ Functional Components (with Hooks):
======================================

Best used when:
Building modern, scalable applications.
Need cleaner, shorter code.
Require advanced state & side-effect handling (useState, useEffect, useReducer, useContext).
Focus on performance optimization (React.memo, useCallback, useMemo).

Examples in Banking Apps:

Real-time dashboards (e.g., live account balance updates with WebSockets or polling).
Fund transfer forms with real-time validations.
Transaction history components (filtering, sorting with APIs).
Micro-frontend modules (separate React apps for loans, deposits, credit cards).

⚡ Why Functional Components Are Preferred Today:
===================================================

Hooks replace lifecycle methods (cleaner useEffect instead of multiple lifecycle methods).
Less boilerplate → shorter code vs. verbose class syntax.
Easier testing & debugging.
Performance optimizations via hooks are straightforward.
Industry adoption → all modern banking & fintech apps use functional components.

🏦 Banking Domain Real-World Use Case
Example: Fund Transfer Page

Functional Component:
Handles form state with useState.
Runs validations (account number length, balance check).
Calls Spring Boot backend APIs using fetch or axios.
Uses useEffect to poll transaction status until completion.

Class Component (Legacy):
========================
Older banking portals may still have this built using componentDidMount, setState, etc.


=========================================================================================



React Component Lifecycle
│
├── Mounting (When component is created & inserted into DOM)
│   ├── constructor()
│   ├── static getDerivedStateFromProps(props, state)
│   ├── render()
│   └── componentDidMount()
│
├── Updating (When props or state change)
│   ├── static getDerivedStateFromProps(props, state)
│   ├── shouldComponentUpdate(nextProps, nextState)
│   ├── render()
│   ├── getSnapshotBeforeUpdate(prevProps, prevState)
│   └── componentDidUpdate(prevProps, prevState, snapshot)
│
└── Unmounting (When component is removed from DOM)
    └── componentWillUnmount()


React Life Cycle with Hooks:
===========================

Functional Component Lifecycle (via useEffect)
│
├── Mounting
│   └── useEffect(() => { ... }, [])
│
├── Updating (dependency change)
│   └── useEffect(() => { ... }, [dependencies])
│
└── Unmounting (cleanup)
    └── useEffect(() => {
          return () => { cleanup code }
        }, [])

================================================

Reconciliation in React
🔹 Definition

Reconciliation is the process by which React updates the DOM to match the latest React elements (virtual DOM).
When the state or props of a component change, React compares the new virtual DOM with the previous virtual DOM and efficiently updates only the parts of the real DOM that changed.

This makes React fast and efficient, as it avoids unnecessary DOM manipulations.

🔹 How Reconciliation Works

React creates a Virtual DOM representation of your UI.
When state or props change, React creates a new Virtual DOM.
React diffs the new virtual DOM against the old one (using a diffing algorithm).
React applies minimal updates to the real DOM to reflect changes.
This process is called “Reconciliation”.

=================================================

What is Redux?

Redux is a state management library for JavaScript applications. 
It is commonly used with React to manage the global state of an application in a predictable way.

React by itself manages local component state using useState or useReducer. 
But in larger apps, multiple components often need to share and update data → that’s where Redux helps.

Component → Action → Store → Reducer → New State → Component (Re-render)

[User Interaction / UI Event]  
        ↓  
 dispatch(action)  
        ↓  
   Redux Store  
        ↓  
    Reducer(s)  
        ↓  
   New State Created  
        ↓  
 React Components re-render  
        ↓  
  Updated UI visible to user


Core Concepts of Redux

Store

The single source of truth (global state container).
Holds the complete state of the application.

Action

A plain JavaScript object describing what happened.
Must have a type property.

Example: { type: "ADD_TODO", payload: "Learn Redux" }

Reducer

A pure function that takes the current state and an action, and returns the new state.

Example: function todoReducer(state = [], action) {
  switch (action.type) {
    case "ADD_TODO":
      return [...state, action.payload];
    default:
      return state;
  }
}

Dispatch

A method used to send actions to the store.

Example: dispatch({ type: "ADD_TODO", payload: "Learn Redux" });

Selector

A function to extract specific data from the store.

==============================================================================================

Three Principles of Redux:
============================

1. Single Source of Truth:
=========================

The entire application state is stored in a single store (a single JavaScript object tree).
This makes it easy to track and debug state changes.

==> Instead of multiple states spread across components, everything is stored centrally.

✅ Example:
 const store = {
  user: { id: 1, name: "Mahesh" },
  cart: [{ id: 101, item: "Laptop", price: 50000 }],
  theme: "dark"
};

2. State is Read-Only:
=====================

The only way to change the state is by dispatching an action.
Components cannot directly modify the store’s state.

✅ Example:

       // ❌ Wrong – directly modifying state
         store.user.name = "John";  

       // ✅ Correct – using action
        dispatch({ type: "UPDATE_NAME", payload: "John" });

   This ensures all changes are explicit and trackable.

3. Changes are Made with Pure Functions

Reducers are pure functions.
A reducer takes previous state + action and returns a new state.
They should not mutate state or perform side effects like API calls.

✅ Example Reducer: 

function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };  // ✅ Pure function
    case "DECREMENT":
      return { count: state.count - 1 };
    default:
      return state;
  }
}











       
